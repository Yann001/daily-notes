> JavaScript高级程序设计学习笔记

[TOC]

## 第一章 JavaScript简介

## 第二章 在HTML中使用JavaScript

### 2.1 < script>元素

1. 延迟脚本（defer属性）：<script defer="defer"></script> 只适用于外部脚本文件，先加载，不执行，一般在</html>后，DOMContentLoaded事件之前执行，最好只包含一个延迟脚本。
2. 异步脚本（async属性）：指定async 属性的目的是不让页面等待脚本下载和执行，也是只适用于外部脚本，从而异步加载页面其他内容，因此异步脚本不要在加载器件修改DOM。标记为async 的脚本并不保证按照指定它们的先后顺序执行


### 2.2 嵌入代码与外部文件

在HTML 中嵌入JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强调如下优点。
- 可维护性：遍及不同HTML 页面的JavaScript 会造成维护问题。但把所有JavaScript 文件都放在一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及HTML 标记的情况下，集中精力编辑JavaScript 代码。
- 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。
- 适应未来：通过外部文件来包含JavaScript 无须使用前面提到XHTML 或注释hack。HTML 和XHTML 包含外部文件的语法是相同的。

### 2.3 文档模式

IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。最初的两种文档模式是：混杂模式（quirks mode）①和标准模式（standards mode）。混杂模式会让IE 的行为与（包含非标准特性的）IE5 相同，而标准模式则让IE 的行为更接近标准行为。虽然这两种模式主要影响CSS内容的呈现，但在某些情况下也会影响到JavaScript 的解释执行。
在IE 引入文档模式的概念后，其他浏览器也纷纷效仿。在此之后，IE 又提出一种所谓的准标准模式（almost standards mode）。这种模式下的浏览器特性有很多都是符合标准的，但也不尽然。不标准的地方主要体现在处理图片间隙的时候（在表格中使用图片时问题最明显）。
如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些hack 技术，跨浏览器的行为根本就没有一致性可言。
对于标准模式，可以通过使用下面任何一种文档类型来开启：
``` html
<!-- HTML 4.01 严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<!-- XHTML 1.0 严格型 -->
<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- HTML 5 -->
<!DOCTYPE html>
```

### 2.4 < noscript>元素

早期浏览器都面临一个特殊的问题，即当浏览器不支持JavaScript 时如何让页面平稳地退化。对这个问题的最终解决方案就是创造一个< noscript>元素，用以在不支持JavaScript 的浏览器中显示替代的内容。这个元素可以包含能够出现在文档< body>中的任何HTML 元素< script>元素除外。包含在< noscript>元素中的内容只有在下列情况下才会显示出来：

- 浏览器不支持脚本
- 浏览器支持脚本，但脚本被禁用

## 第三章 基本概念

### 语法

1. 区分大小写
2. 标识符：第一个字母为字母、下划线或美元符$。驼峰式命名（getElementById）。
3. 注释：单行//  块级注释（多行）/* 开头 */结尾。
4. 严格模式：脚本中添加 "use strict"。
5. 语句：推荐末尾加分号，尽量使用代码块（使用{}将代码括起来），哪怕if语句后只有一句代码。
6. 变量：使用 var 关键字定义，未初始化时会保存一个特殊的值--undefined，在修改变量值得同时可以修改变量的类型，但不推荐，通过var定义的变量是局部变量。省略var关键字课定义全局变量，但不推荐。

### 数据类型

ECMAScript中有5种简单数据类型：Undefined、Null、Boolean、Number、String。1种复杂数据类型Object。

#### typeof 操作符

typeof操作符（不是函数，可以不要()）：返回下列某个字符串

- "undefined"--如果值未定义
- "boolean"--如果值是布尔值
- "string"--如果值是字符串
- "number"--如果值是数值
- "object"--如果值是对象或null
- "function"--如果值是函数


#### Undefined类型

Undefined类型只有一个值，即特殊的undefined。对于声明未进行初始化或未进行声明的变量使用typeof操作符都会返回"undefined"。

#### Null类型

Null类型，也只有一个值null（逻辑上看表示一个空对象指针），实际上undefined是派生自null的对它们使用==符号判断时会返回true。

#### Boolean类型

Boolean类型，只有true和false两个值。
可以对任何数据类型的值调用Boolean()函数
对应返回值如下：

|数据类型|返回true|返回false|
|--|--|--|
|Boolean|true|false|
|String|任何非空字符串|""（空字符串）|
|Number|任何非零数字值（包括无穷大）|0和NaN|
|Object|任何对象|Null|
|Undefined|N/A（not applicable）不适用|undefined|

#### Number类型

- 十进制
- 八进制（0开头，如果后面包含大于7的数字，则会忽略0，直接解析成十进制数）
- 十六进制（0x开头，后面字母可大写可小写）。

在进行算数运算时，最终都将转换成十进制数值。可以保存正零（+0）和负零（-0），正零和负零被认为相等。

**浮点数值：**

- 数值中必须包含一个小数点，并且小数点后面至少有一位数字。
- 可以用e/E表示法（科学计数法）表示数值。
- 浮点数的最高精度是17位小数。
- 默认情况下，ECMAScript会将小数点后面带有6个零以上的数值转换成e表示法表示的数值。

**数值范围：**

- ECMAScript表示的最大值保存在Number.MAX_VALUE中，最小值保存在Number.MIN_VALUE中
- 超出范围将会自动转换成特殊值+Infinity或-Infinity，可以使用isFinite函数判断一个数值是否是有穷的。

**NaN**

NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数
未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0 都会导致错误，
从而停止代码执行。但在ECMAScript 中，任何数值除以0会返回一个值（0/0返回NaN，正数/0返回Infinity，负数/0返回-Infinity），因此不会影响其他代码的执行。

**数值转换：**

Number()、parseInt()、parseFloat()。

Number()函数的转换规则如下。

- 如果是Boolean 值，true 和false 将分别被转换为1 和0。
- 如果是数字值，只是简单的传入和返回。
- 如果是null 值，返回0。
- 如果是undefined，返回NaN。
- 如果是字符串，遵循下列规则：
    - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成1，"123"会变成123，而"011"会变成11（注意：前导的零被忽略了）；
    - 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）；
    - 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
    - 如果字符串是空的（不包含任何字符），则将其转换为0；
    - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

parseInt(val[, 10|16|8|2])参数解析

- val为带转化为数字的值
- 第二个参数为可选参数，表示按几进制进行数值的解析，不传递则按照十进制进行解析

#### String类型

字符串可以由双引号（"）或单引号（'）表示，用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。

**1. 字符字面量**

String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：

|字面量|含义|
|--|--|
|\n|换行|
|\t|制表|
|\b|空格|
|\r|回车|
|\f|进纸|
|\\|斜杠|
|\'|单引号（'）（'），在用单引号表示的字符串中使用。例如：'He said, \'hey.\''|
|\"|双引号（"）（"），在用双引号表示的字符串中使用。例如："He said, \"hey.\""|
|\xnn|以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示"A"|
|\unnnn|以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ|

** 2. 字符串的特点**

ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，
例如：

``` js
var lang = "Java";
lang = lang + "Script";
```

以上示例中的变量lang 开始时包含字符串"Java"。而第二行代码把lang 的值重新定义为"Java"与"Script"的组合，即"JavaScript"。实现这个操作的过程如下：首先创建一个能容纳10 个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"，因为这两个字符串已经没用了。

**3. 转换为字符串**

要把一个值转换为一个字符串的方法有两个:

- toString()方法
- String()方法。

也可使用加号操作符+把它与一个字符串""连在一起。

数值、布尔值、对象和字符串值（每个字符串也都有一个toString()方法，该方法返回字
符串的一个副本）都有toString()方法。但null 和undefined 值没有这个方法。

多数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。如：

``` js
var num = 10;
alert(num.toString()); // "10"
alert(num.toString(2)); // "1010"
alert(num.toString(8)); // "12"
alert(num.toString(10)); // "10"
alert(num.toString(16)); // "a"
```

在不知道要转换的值是不是null 或undefined 的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则：

- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；
- 如果值是null，则返回"null"；
- 如果值是undefined，则返回"undefined"。

#### Object类型

Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。
Object 的每个实例都具有下列属性和方法。

- constructor，保存着用于创建当前对象的函数。
- hasOwnProperty(propertyName)，用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty("name")）。
- isPrototypeOf(object)，用于检查传入的对象是否是传入对象的原型。
- propertyIsEnumerable(propertyName)，用于检查给定的属性是否能够使用for-in 语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
- toLocaleString()，返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()，返回对象的字符串表示。
- valueOf()，返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

从技术角度讲，ECMA-262 中对象的行为不一定适用于JavaScript 中的其他对象。浏览器环境中的对象，比如BOM 和DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。

### 操作符

#### 一元操作符

只能操作一个值的操作符叫做一元操作符。

**1. 递增和递减操作符**

- 前置型 ++i, --i (副效应)
- 后置型 i++, i--

所有这4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。

- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1 的操作。字符串变量变成数值变量。
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN，字符串变量变成数值变量。
- 在应用于布尔值false 时，先将其转换为0 再执行加减1 的操作。布尔值变量变成数值变量。
- 在应用于布尔值true 时，先将其转换为1 再执行加减1 的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时，执行加减1 的操作。
- 在应用于对象时，先调用对象的valueOf()方法，以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

示例：

``` js
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
  return -1;
  }
};
s1++; // 值变成数值3
s2++; // 值变成NaN
b++; // 值变成数值1
f--; // 值变成0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值-2
```

**2. 一元加和减操作符**

一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。不过，在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。换句话说，布尔值false 和true 将被转换为0 和1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的valueOf()和（或）toString()方法，再转换得到的值。

示例：

``` js
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
  return -1;
  }
};
s1 = +s1; // 值变成数值1
s2 = +s2; // 值变成数值1.1
s3 = +s3; // 值变成NaN
b = +b; // 值变成数值0
f = +f; // 值未变，仍然是1.1
o = +o; // 值变成数值-1
```

一元减操作符主要用于表示负数，例如将1 转换成-1。当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

示例：

``` js
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
  return -1;
  }
};
s1 = -s1; // 值变成了数值-1
s2 = -s2; // 值变成了数值-1.1
s3 = -s3; // 值变成了NaN
b = -b; // 值变成了数值0
f = -f; // 变成了-1.1
o = -o; // 值变成了数值1
```

一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。

#### 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位

**1. 按位非（NOT）**

按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。
如：

``` js
var num1 = 25; // 二进制00000000000000000000000000011001
var num2 = ~num1; // 二进制11111111111111111111111111100110
alert(num2); // -26
```

**2. 按位与（AND）**

按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，对相同位置上的两个数执行AND操作。
按位与操作只在两个数值的对应位都是1 时才返回1，任何一位是0，结果都是0。

**3. 按位或（OR）**

按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。
按位或操作在有一个位是1 的情况下就返回1，而只有在两个位都是0 的情况下才返回0。

**4. 按位异或（XOR）**

按位异或操作符由一个插入符号（^）表示，也有两个操作数。
这个操作在两个数值对应位上只有一个1 时才返回1，如果对应的两位都是1 或都是0，则返回0。

**5. 左移**

左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，如果将数值2（二进制码为10）向左移动5 位，结果就是64（二进制码为1000000）。
注意，在向左移位后，原数值的右侧多出了5 个空位。左移操作会以0 来填充这些空位，以便得到的结果是一个完整的32位二进制数。

**6. 有符号的右移**

有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。

**7. 无符号右移**

无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同，但是对负数来说，情况就不一样了。首先，无符号右移是以0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。

#### 布尔操作符

**1. 逻辑非**

逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则：

- 如果操作数是一个对象，返回false；
- 如果操作数是一个空字符串，返回true；
- 如果操作数是一个非空字符串，返回false；
- 如果操作数是数值0，返回true；
- 如果操作数是任意非0 数值（包括Infinity），返回false；
- 如果操作数是null，返回true；
- 如果操作数是NaN，返回true；
- 如果操作数是undefined，返回true。

**2. 逻辑与**

逻辑与操作符由两个和号（&&）表示，有两个操作数，逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第二个操作数；
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true 的情况下才会返回该
- 对象；
- 如果两个操作数都是对象，则返回第二个操作数；
- 如果有一个操作数是null，则返回null；
- 如果有一个操作数是NaN，则返回NaN；
- 如果有一个操作数是undefined，则返回undefined。

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。

**3. 逻辑或**

逻辑或操作符由两个竖线符号（||）表示，有两个操作数，与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第一个操作数；
- 如果第一个操作数的求值结果为false，则返回第二个操作数；
- 如果两个操作数都是对象，则返回第一个操作数；
- 如果两个操作数都是null，则返回null；
- 如果两个操作数都是NaN，则返回NaN；
- 如果两个操作数都是undefined，则返回undefined。

与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

#### 乘性操作符

**1. 乘法**

乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。
在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript 数值的表示范围，则返回Infinity 或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 与0 相乘，则结果是NaN；
- 如果是Infinity 与非0 数值相乘，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity 与Infinity 相乘，则结果是Infinity；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

**2. 除法**

除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算

与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：

- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript 数值的表示范围，则返回Infinity 或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 被Infinity 除，则结果是NaN；
- 如果是零被零除，则结果是NaN；
- 如果是非零的有限数被零除，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity 被任何非零数值除，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

**3. 求模**
求模（余数）操作符由一个百分号（%）表示
与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；
- 如果被除数是有限大的数值而除数是零，则结果是NaN；
- 如果是Infinity 被Infinity 除，则结果是NaN；
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 加性操作符

**1. 加法**

如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 加Infinity，则结果是Infinity；
- 如果是-Infinity 加-Infinity，则结果是-Infinity；
- 如果是Infinity 加-Infinity，则结果是NaN；
- 如果是+0 加+0，则结果是+0；
- 如果是-0 加-0，则结果是-0；
- 如果是+0 加-0，则结果是+0；
- 如果有一个操作数是字符串，那么就要应用如下规则：
  - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。
- 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined 和null，则分别调用String()函数并取得字符串"undefined"和"null"。

**2. 减法**

与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示：

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 减Infinity，则结果是NaN；
- 如果是-Infinity 减-Infinity，则结果是NaN；
- 如果是Infinity 减-Infinity，则结果是Infinity；
- 如果是-Infinity 减Infinity，则结果是-Infinity；
- 如果是+0 减+0，则结果是+0；
- 如果是+0 减-0，则结果是-0；
- 如果是-0 减-0，则结果是+0；
- 如果有一个操作数是字符串、布尔值、null 或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；
- 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

#### 关系操作符

小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个关系操作符用于对两个值进行比较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值

与ECMAScript 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。

- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
- 任何操作数与NaN 进行关系比较，结果都是false。

#### 相等操作符

**1. 相等和不相等**

ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回true。而不相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回true。这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为0，而true 转换为1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
- 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；
- 这两个操作符在进行比较时则要遵循下列规则。
  - null 和undefined 是相等的。
  - 要比较相等性之前，不能将null 和undefined 转换成其他任何值。
- 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN 不等于NaN。
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

**2. 全等和不全等**

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。

#### 条件操作符

``` js
variable = boolean_expression ? true_value : false_value;
```

这行代码的含义就是基于对boolean_expression 求值的结果，决定给变量variable赋什么值。如果求值结果为true，则给变量variable 赋true_value 值；如果求值结果为false，则给变量variable 赋false_value 值。

#### 赋值操作符

简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量。
如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。
每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：

- 乘/赋值（*=）；
- 除/赋值（/=）；
- 模/赋值（%=）；
- 加/赋值（+=）；
- 减/赋值（-=）；
- 左移/赋值（<<=）；
- 有符号右移/赋值（>>=）；
- 无符号右移/赋值（>>>=）。

设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。

#### 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：
``` js
var num1=1, num2=2, num3=3;
```

逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：
``` js
var num = (5, 1, 4, 8, 0); // num 的值为0
```

由于0 是表达式中的最后一项，因此num 的值就是0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。


### 语句

语句：

- if else
- do while
- while
- for（由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在循环外部访问）
- for in
- label（label:statement）
- with（不建议使用，严格模式下不允许）
- switch

ECMAScript 对象的属性没有顺序。因此，通过for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。
但是，如果表示要迭代的对象的变量值为null 或undefined，for-in 语句会抛出错误。ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in 循环之前，先检测确认该对象的值不是null 或undefined。


### 函数

return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。比如在下面这个例子中，就不会显示警告框：
``` js
function sayHi(name, message) {
  return;
  alert("Hello " + name + "," + message); //永远不会调用
}
```

严格模式对函数有一些限制：

- 不能把函数命名为eval 或arguments；
- 不能把参数命名为eval 或arguments；
- 不能出现两个命名参数同名的情况。

如果发生以上情况，就会导致语法错误，代码无法执行。

**函数：arguments对象**

- arguments对象是一个类数组对象，可通过下标访问其属性，也具有length属性，但其并不是Array的实例
- 函数中可以使用arguments对象访问参数
- arguments[index]可与参数名混用
- 没有传递值得命名参数将自动被赋予undefined值
- 严格模式对如何使用arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。重写arguments 的值会导致语法错误（代码将不会执行）。

**ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。**

**ECMAScript 函数没有重载**

定义命名相同的两个函数时，后定义的函数将会覆盖之前定义的函数。


## 第四章 变量、作用域和内存问题

### 基本类型和引用类型的值

**1. 动态属性**

只能给引用类型值动态添加属性

**2. 复制变量值**

复制基本类型值时会创建独立的副本，但复制引用类型的值时两个变量将引用同一个对象。

**3. 传递参数**

所有函数的参数都是按照值传递的。

**4. 检测类型**

- typeof
- instanceof

### 执行环境及作用域

执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境。根据ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web 浏览器中，全局执行环境被认为是window 对象（第7 章将详细讨论），因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。
当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。

Web浏览器中，全局执行环境被认为是windows对象。
内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

**延长作用域链**

- 当执行流进入下列任何一个语句时，作用域链就会得到加长：
- try-catch语句的catch块
- with语句

对with 语句来说，会将指定的对象添加到作用域链中。
对catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

**没有块级作用域**

- 声明变量：如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中。严格模式下，不声明会导致错误。
- 查询标识符：作用域链逐级向上搜索。
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。


### 垃圾收集

1. 标记清除（常用）
2. 引用计数
3. 性能问题（垃圾收集器周期运行）
4. 管理内存
使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，

## 第五章 引用类型

用类型的值（对象）是引用类型的一个实例。在ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
虽然引用类型与类看起来相似，但它们并不是相同的概念。

ECMAScript提供了很多原生引用类型,如：

- Object
- Array

### Object类型

**对象创建**

- var obj = new Object()，new操作符后跟Object构造函数形式
- var obj = {}，对象字面量方式

*在通过对象字面量定义对象时，实际上不会调用Object构造函数（Firefox2及更早版本会调用Object构造函数；但Firefox3之后就不会了）。*

**访问属性**

- `.`
- `[]`

对象属性名中是可以包含非字母非数字的，有时不能用点号方式访问时就用方括号形式，或属性是变量时也用方括号形式。一般建议用点号方式。

### Array类型

**创建**

- 构造函数，var arr = new Array()或new Array(10)或new Array('red', 'green', 'blue')，其中new可以省略，效果一样。
- 字面量形式，var arr = [];

数组最多可以包含4 294 967 295 个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。

#### 检测数组

- instance of
- Array.isArray()

value instanceof Array 会因存在两个或以上的全局环境出现问题，ECMAScript 5新增了Array.isArray(value)方法，检测值value是不是数组。

#### 转换方法

- toString()，返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串
- valueOf()，返回的还是数组
- toLocaleString()，toLocaleString()方法经常也会返回与toString()和valueOf()方法相同的值
- join(),可以使用不同的分隔符来构建数组toString()的字符串

#### 栈方法

- push()，可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
- pop()，从数组末尾移除最后一项，减少数组的length 值，然后返回移除的项。

#### 队列方法

- shift()，移除数组中的第一个项并返回该项，同时将数组长度减1。
- unshift，在数组前端添加任意个项并返回新数组的长度。

#### 重排序方法

- reverse()，反转数组项的顺序。
- sort()，在默认情况下，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。

sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。

**reverse()和sort()方法的返回值是经过排序之后的数组，由于数组是引用类型，两个方法都会改变原数组，如果不想改变原数组，可将原数组深拷贝（可用数组concat或slice方法）一份再对副本进行操作。**




#### 操作方法

- concat()，，concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。
- slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。

*注意，slice()方法不会影响原始数组。方法返回数组中的某一段，如果该方法中包含负数，则用数组长度加上该数来确定位置，结束位置小于起始位置时返回空数组。*

- splice()方法
  - 删除，可以删除任意数量的项，只需指定2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。
  - 插入，可以向指定位置插入任意数量的项，只需提供3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。
  - 替换，可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

*splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）*


#### 位置方法

- indexOf()
- lastIndexOf()方法，返回要查找的项在数组中第一次出现位置的索引值。

这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回.1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）

#### 迭代方法

ECMAScript 5 为数组定义了5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5 个迭代方法的作用。

- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。
- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

**以上方法都不会修改数组中的包含的值。**

#### 归并方法

- reduce()
- reduceRight()

ECMAScript 5 还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。
这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。



### Date类型

ECMAScript 中的Date 类型是在早期Java 中的java.util.Date 类基础上构建的。为此，Date类型使用自UTC（Coordinated Universal Time，国际协调时间）1970 年1 月1 日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date 类型保存的日期能够精确到1970 年1月1 日之前或之后的285 616 年。

要创建一个日期对象，使用new 操作符和Date 构造函数即可，如下所示。
``` js
var now = new Date();
```

在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC 时间1970 年1 月1 日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法：

- Date.parse()
- Date.UTC()

Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262 没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。
将地区设置为美国的浏览器通常都接受下列日期格式：

- “月/日/年”，如 6/13/2004
- “英文月名 日,年”，如 January 12,2004
- “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700
- ISO 8601 扩展格式YYYY-MM-DDTHH:mm:ss.sssZ，如 （2004-05-25T00:00:00），只有兼容ECMAScript 5 的实现支持这种格式。

例如，要为2004 年5 月25 日创建一个日期对象，可以使用下面的代码：
``` js
var someDate = new Date(Date.parse("May 25, 2004"));
```

如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date 构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前面的例子是等价的：
``` js
var someDate = new Date("May 25, 2004");
```

这行代码将会得到与前面相同的日期对象。

Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0 的月份（一月是0，二月是1，以此类推）、月中的哪一天（1 到31）、小时数（0 到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。
以下是两个使用Date.UTC()方法的例子：
``` js
// GMT 时间2000 年1 月1 日午夜零时
var y2k = new Date(Date.UTC(2000, 0));
// GMT 时间2005 年5 月5 日下午5:55:55
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
```

如同模仿Date.parse()一样，Date 构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT 来创建。不过，Date 构造函数接收的参数仍然与Date.UTC()相同。
因此，如果第一个参数是数值，Date 构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。据此，可以将前面的例子重写如下。
``` js
// 本地时间2000 年1 月1 日午夜零时
var y2k = new Date(2000, 0);
// 本地时间2005 年5 月5 日下午5:55:55
var allFives = new Date(2005, 4, 5, 17, 55, 55);
```

以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区创建的。

**Date.now()**

ECMAScript 5 添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。

#### 继承的方法

- toString()
- toLocaleString()
- valueOf()

Date 类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM 或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0 到23）表示。
这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。
至于Date 类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值。

#### 日期格式化方法

Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。

- toDateString()——以特定于实现的格式显示星期几、月、日和年；
- toTimeString()——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
- toUTCString()——以特定于实现的格式完整的UTC 日期。

与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

除了前面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript 推荐现在编写的代码一律使用toUTCString()方法。

#### 日期/事件组件方法

还有部分Date 类型的方法（如下表所示），都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC 日期指的是在没有时区偏差的情况下（将日期转换为GMT 时间）的日期值。

|方法|说明|
|--|--|
|getTime() |返回表示日期的毫秒数；与valueOf()方法返回的值相同
|setTime(毫秒) |以毫秒数设置日期，会改变整个日期
|getFullYear() |取得4位数的年份（如2007而非仅07）
|getUTCFullYear() |返回UTC日期的4位数年份
|setFullYear(年) |设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
|setUTCFullYear(年) |设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
|getMonth() |返回日期中的月份，其中0表示一月，11表示十二月
|getUTCMonth() |返回UTC日期中的月份，其中0表示一月，11表示十二月
|setMonth(月) |设置日期的月份。传入的月份值必须大于0，超过11则增加年份
|setUTCMonth(月) |设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
|getDate() |返回日期月份中的天数（1到31）
|getUTCDate() |返回UTC日期月份中的天数（1到31）
|setDate(日) |设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
|setUTCDate(日) |设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
|getDay() |返回日期中星期的星期几（其中0表示星期日，6表示星期六）
|getUTCDay() |返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）
|getHours() |返回日期中的小时数（0到23）
|getUTCHours() |返回UTC日期中的小时数（0到23）
|setHours(时) |设置日期中的小时数。传入的值超过了23则增加月份中的天数
|setUTCHours(时) |设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
|getMinutes() |返回日期中的分钟数（0到59）
|getUTCMinutes() |返回UTC日期中的分钟数（0到59）
|setMinutes(分) |设置日期中的分钟数。传入的值超过59则增加小时数
|setUTCMinutes(分) |设置UTC日期中的分钟数。传入的值超过59则增加小时数
|getSeconds() |返回日期中的秒数（0到59）
|getUTCSeconds() |返回UTC日期中的秒数（0到59）
|setSeconds(秒) |设置日期中的秒数。传入的值超过了59会增加分钟数
|setUTCSeconds(秒) |设置UTC日期中的秒数。传入的值超过了59会增加分钟数
|getMilliseconds() |返回日期中的毫秒数
|getUTCMilliseconds() |返回UTC日期中的毫秒数
|setMilliseconds(毫秒) |设置日期中的毫秒数
|setUTCMilliseconds(毫秒) |设置UTC日期中的毫秒数
|getTimezoneOffset() |返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化



### RegExp类型

ECMAScript 通过RegExp 类型来支持正则表达式。使用下面类似Perl 的语法，就可以创建一个正则表达式。
``` js
var expression = / pattern / flags;
var regexp = new RegExp(pattern, flags);
```

其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
正则表达式的匹配模式支持下列3个标志:

- **g**：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- **i**：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- **m**：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：
`( ) [ ] { } + * ^ $ | \ . ?`
这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。

要注意的是，传递给RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp 构造函数）。由于RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\\，而在正则表达式字符串中就会变成\\\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp 构造函数定义相同模式时使用的字符串。

|字面量形式|等价字符串|
|--|--|
|/\[bc\]at/| "\\[bc\\]at"|
|/\.at/ "\\|.at"|
|/name\/age/| "name\\/age"|
|/\d.\d{1,2}/| "\\d.\\d{1,2}"|
|/\w\\hello\\123/| "\\w\\\\hello\\\\123"|

使用正则表达式字面量和使用RegExp 构造函数创建的正则表达式不一样。在ECMAScript 3 中，正则表达式字面量始终会共享同一个RegExp 实例，而使用构造函数创建的每一个新RegExp 实例都是一个新实例。来看下面的例子。

``` js
var re = null, i;
for (i=0; i < 10; i++) {
  re = /cat/g;
  re.test("catastrophe");
}
for (i=0; i < 10; i++) {
  re = new RegExp("cat", "g");
  re.test("catastrophe");
}
```

在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp 实例。由于实例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用test()方法会失败。这是因为第一次调用test()找到了"cat"，但第二次调用是从索引为3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就又从开头开始了。第二个循环使用RegExp 构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp 实例，所以每次调用test()都会返回true。
ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用RegExp 构造函数一样，每次都创建新的RegExp 实例。IE9+、Firefox 4+和Chrome 都据此做出了修改。

#### RegExp实例属性

- RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- global：布尔值，表示是否设置了g 标志。
- ignoreCase：布尔值，表示是否设置了i 标志。
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0 算起。
- multiline：布尔值，表示是否设置了m 标志。
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。

#### RegExp实例方法

**1. exec() 方法**

RegExp 对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。
如下面例子：

``` js
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;

var matches = pattern.exec(text);

alert(matches.index); // 0
alert(matches.input); // "mom and dad and baby"
alert(matches[0]); // "mom and dad and baby"
alert(matches[1]); // " and dad and baby"
aler t(matches[2]); // " and baby"
```

这个例子中的模式包含两个捕获组。最内部的捕获组匹配"and baby"，而包含它的捕获组匹配"anddad"或者"and dad and baby"。当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs 的index 属性值为0。数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。

``` js
var text = "cat, bat, sat, fat";
var pattern1 = /.at/;

var matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0

matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0


var pattern2 = /.at/g;
var matches = pattern2.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern2.lastIndex); //3

matches = pattern2.exec(text);
alert(matches.index); //5
alert(matches[0]); //bat
alert(pattern2.lastIndex); //8
```

这个例子中的第一个模式pattern1 不是全局模式，因此每次调用exec()返回的都是第一个匹配项（"cat"）。而第二个模式pattern2 是全局模式，因此每次调用exec()都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的lastIndex 属性的变化情况。在全局匹配模式下，lastIndex 的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。

*IE 的JavaScript 实现在lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex 属性每次也会变化。*

**2. test() 方法**

正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。

**3. 继承方法**

RegExp 实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。正则表达式的valueOf()方法返回正则表达式本身。

#### RegExp构造函数属性

TODO...

#### 模式的局限性

TODO...


### Function类型

函数实际上是对象。每个函数都是Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

**函数定义**

``` js
// 方式一 函数声明形式
function sum (num1, num2) {
  return num1 + num2;
}
//方式二 函数表达式形式
var sum = function(num1, num2){
  return num1 + num2;
};
// 方式三 构造函数形式
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。
由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字，如下面的例子所示。
``` js
function sum(num1, num2){
  return num1 + num2;
}
alert(sum(10,10)); //20
var anotherSum = sum;
alert(anotherSum(10,10)); //20
sum = null;
alert(anotherSum(10,10)); //20
```

以上代码首先定义了一个名为sum()的函数，用于求两个值的和。然后，又声明了变量anotherSum，并将其设置为与sum 相等（将sum 的值赋给anotherSum）。注意，使用不带圆括号的函数名是访问函数指针，而非调用函数。此时，anotherSum 和sum 就都指向了同一个函数，因此anotherSum()也可以被调用并返回结果。即使将sum 设置为null，让它与函数“断绝关系”，但仍然可以正常调用anotherSum()。

#### 没有重载


#### 函数声明与函数表达式

**区别**

解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

*也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari 中会导致错误。*

#### 作为值的函数

因为ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。

#### 函数内部属性

两个特殊对象：arguments和this。

- arguments主要用途是保存函数参数，还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
- this引用的是函数执行的环境对象，当在网页的全局作用域中调用函数时，this对象引用的就是windows。

ECMAScript 5 也规范化了另一个函数对象的属性：caller。除了Opera 的早期版本不支持，其他浏览器都支持这个ECMAScript 3 并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null

#### 函数的属性和方法

函数是一个对象，每个函数都包含两个属性：length和prototype。

- length属性表示函数希望接受的命名参数的个数。
- prototype，对于ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype 名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的。在ECMAScript 5 中，prototype 属性是不可枚举的，因此使用for-in 无法发现。


每个函数都包含两个非继承而来的方法：

- apply()
- call()

这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this 对象的值。
apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象
例如：
``` js
function sum(num1, num2){
  return num1 + num2;
}
function callSum1(num1, num2){
  return sum.apply(this, arguments); // 传入arguments 对象
}
function callSum2(num1, num2){
  return sum.apply(this, [num1, num2]); // 传入数组
}
alert(callSum1(10,10)); //20
alert(callSum2(10,10)); //20
```

在上面这个例子中，callSum1()在执行sum()函数时传入了this 作为this 值（因为是在全局作用域中调用的，所以传入的就是window 对象）和arguments 对象。而callSum2 同样也调用了sum()函数，但它传入的则是this 和一个参数数组。这两个函数都会正常执行并返回正确的结果。

*在严格模式下，未指定环境对象而调用函数，则this 值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是undefined。*

call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。
``` js
function sum(num1, num2){
  return num1 + num2;
}
function callSum(num1, num2){
  return sum.call(this, num1, num2);
}
alert(callSum(10,10)); //20
```

在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）

事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。
``` js
window.color = "red";
var o = { color: "blue" };
function sayColor(){
  alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```

这个例子是在前面说明this 对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示"red"——因为对this.color 的求值会转换成对window.color 的求值。而sayColor.call(this)和sayColor.call(window)，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示"red"。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this 对象指向了o，于是结果显示的是"blue"。

使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在一般的写法中，我们是先将sayColor()函数放到对象o 中，然后再通过o 来调用它的；而在这里重写的例子中，就不需要这个多余的步骤了。

ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值。例如：
``` js
window.color = "red";
var o = { color: "blue" };
function sayColor(){
  alert(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor(); //blue
```

在这里，sayColor()调用bind()并传入对象o，创建了objectSayColor()函数。objectSayColor()函数的this 值等于o，因此即使是在全局作用域中调用这个函数，也会看到"blue"。

每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf()方法同样也只返回函数代码。

### 基本包装类型


三个特殊的引用类型：

- Boolean
- Number
- String。


引用类型与基本包装类型的主要区别就是对象的生存期。

#### Boolean类型

布尔表达式中的所有对象都会被转成true

#### Number类型

toFixed()（四舍五入）、toExponential()（e表示法）、toPrecision()方法（自动选择合适方法）。

#### String类型

字符方法：charAt()、charCodeAt()。
字符串操作方法：concat()、slice()、substr()、substring()。
字符串位置方法：indexOf()、lastIndexOf()。
trim()方法：删除前缀及后缀空格。
字符串大小写转换方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()。
字符串模式匹配方法：match()方法与RegExp的exec()方法相同，search()方法返回字符串中的第一个匹配项的索引，始终从字符串开头向后查找。replace()方法；split()方法。
localeCompare()方法：比较两个字符串并返回1、0或-1。
fromCharCode()方法：静态方法，接受字符编码转换成字符串，与charCodeAt()相反。

7. 单体内置对象

Global对象
  1. URI编码方法：
    - encodeURI()--替换空格；
    - encodeURIComponent()--替换所有非字母数字字符；
    - decodeURI()方法；
    - decodeURIComponent()方法。
  2. eval()方法：
  3. Global对象属性：特殊值，原声引用类型构造函数都是Global对象属性。
  4. window对象

Math对象
  1. 属性：大都是数学计算中可能会用到的一些特殊值
  2. min()和max()方法。
  3. 舍入方法：
    - Math.ceil()：向上舍入
    - Math.floor()：向下舍入
    - Math.round()：标准四舍五入
  4. random()方法
	5. 其他还包括一些完成简单或复杂计算的方法。

## 第六章 面向对象的程序设计

扩展知识：属性名前加下划线表示只能通过对象方法访问的属性（p141）

### 理解对象

#### 属性类型

ECMAScript 中有两种属性：数据属性和访问器属性。

**1. 数据属性**

数据属性有四个描述其行为的特性：

- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特型，或者能否把属性修改为访问器属性。默认值为true。
- [[Enumerable]]：表示能否通过for in 返回属性。默认值为true。
- [[Writable]]：表示能否修改属性的值。默认值为true。
- [[Value]]：包含这个属性的数据值。默认值为undefined。


要修改属性的默认特性（以上四个），必须使用ECMAScript5的Object.defineProperty()方法。该方法接收三个参数，属性所在对象、属性的名字和一个描述符对象（以上四个）。调用该方法时，如果不指定，四个特性的默认值都是false。
例如：

``` js
var person = {};
Object.defineProperty(person, "name", {
  writable: false,
  value: "Nicholas"
});
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
```
这个例子创建了一个名为name 的属性，它的值"Nicholas"是只读的。这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。



**2. 访问器属性**

访问器属性有四个特性：

- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特型，或者能否把属性修改为访问器属性。默认值为true。
- [[Enumerable]]：表示能否通过for in 返回属性。默认值为true。
- [[Get]]：在读取属性时调用的函数。默认值为undefined。
- [[Set]]：在写入属性时调用的函数。默认值为undefined。


访问器属性不能直接定义，必须使用Object.defineProperty()来定义。
如下面的例子：
``` js
var book = {
  _year: 2004,
  edition: 1
};
Object.defineProperty(book, "year", {
  get: function(){
    return this._year;
  },
  set: function(newValue){
    if (newValue > 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
});
book.year = 2005;
alert(book.edition); //2
```

以上代码创建了一个book 对象，并给它定义两个默认的属性：_year 和edition。_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year 则包含一个getter 函数和一个setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此，把year 属性修改为2005 会导致_year 变成 2005，而edition 变为2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。
不一定非要同时指定getter 和setter。只指定getter 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter 函数的属性会抛出错误。类似地，只指定setter 函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。


#### 定义多个属性

Object.defineProperties()方法，第一个参数是要添加和修改其属性的对象，第二个与第一个对象中要添加或修改的属性一一对应。


#### 读取属性的特性

Object.getOwnPropertyDescriptor()方法，参数为属性所在对象和要读取属性的名称，返回值是一个对象。

### 创建对象


#### 工厂模式

用函数来封装已特定接口创建对象的细节。
构造函数模式
原型模式：
创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
isPrototypeOf()方法
Object.getPrototypeOf()方法
hasOwnProperty()方法
原型与in操作符，只要能通过对象访问到属性就返回true，hasOwnProperty()只有属性存在于实例中时才返回true，因此只要in操作符返回true，而hasOwnProperty()返回false，就可以确定属性是原型中的属性。 
Object.keys()方法取得对象上所有可以枚举的属性。
Object.getOwnPropertyNames()方法取得所有实例属性，包括不可枚举（constructor等）
原型的动态性
原生对象的原型
组合使用原型模式和构造函数模式
寄生构造函数模式
稳妥构造函数模式

3. 继承
原型链


## 第七章 函数表达式

函数声明、函数表达式（匿名函数、拉姆达函数）
1. 递归
arguments.callee是一个指向正在执行函数的指针。也可使用一个命名的函数表达式来实现。

2. 闭包
闭包与变量
关于this对象
内存泄漏

3. 模仿块级作用域
``` js
(function (){
	//块级作用域
})();
```
函数表达式后面可以跟圆括号，而函数声明后面不能跟圆括号。

4. 私有变量
特权方法（有权访问私有变量的公有方法）
静态私有变量
模块模式：如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。
增强的模块模式

## 第八章 BOM

1. window对象
BOM对象的核心是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。
全局作用域：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。尝试访问未声明的变量会出错，但可以通过查询window对象，可以知道某个可能未声明的变量是否存在。
窗口关系及框架：
``` html
<frameset><frame></frame></frameset>
```
window.frames[0]、top.frames[0]。
parent，在没有框架的情况下parent一定等于top，它们都等于window。
窗口位置：
screenLeft和screenTop属性（screenX，screenY）。moveTo()和moveBy()方法。
窗口大小：
innerWidth、innerHeight、outerWidth、outerHeight。
resizeTo()、resizeBy()方法可以调整浏览器窗口的大小。
导航和打开窗口：
window.open()。
window.close()，仅适用于window.open()打开的窗口，对于浏览器的主窗口，如果没有得到用户允许是不能关闭它的。
新创建的window对象有一个opener属性，其中保存着打开他的原始窗口对象。
安全限制（弹出窗口）
弹出窗口屏蔽程序
间歇调用和超时调用：
超时调用，setTimeout()，第一个参数可以是包含JS代码的字符串，也可以是一个函数（推荐），第二个参数是毫秒表示的时间。调用setTimeout()方法之后，会返回一个数值ID，表示超时调用，这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。
demo：
``` js
//设置超时调用
var timeoutId = setTimeout(function(){
	alert("hello world !");
}, 1000);
//把它取消
clearTimeout(timeoutId);
//执行以上代码什么都不会发生。
```
间歇调用，setInterval()，clearInterval()使用与超时调用类似。
系统对话框：
alert()、confirm()、prompt()。

2. location对象

3. navigator对象

4. screen对象

5. history对象

## 第九章 客户端检测

1. 能力检测（特性检测）
2. 怪癖检测
3. 用户代理检测：
主流四大浏览器内核：
	- Trident ：Internet Explore
	- Gecko：Mozilla Firefox、Netscape
	- WebKit：Safari、Chrome
	- Presto：Opera

## 第十章 DOM

DOM（文档对向模型）是针对HTML和XML文档的一个API。

1. 节点层次
文档节点（document）是每个节点的根节点。总共有12种节点类型。
Node类型
每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个常量属性来表示：
  1. Node.ELEMENT_NODE=1
  2. Node.ATTRIBUTE_NODE=2
  3. Node.TEXT_NODE=3
  4. Node.CDATA_SECTION_NODE=4
  5. Node.ENTITY_REFERENCE_NODE=5
  6. Node.ENTITY_NODE=6
  7. Node.PROCESSING_INSTRUCTION_NODE=7
  8. Node.COMMENT_NODE=8
  9. Node.DOCUMENT_NODE=9
  10. Node.DOCUMENT_TYPE_NODE=10
  11. Node.DOCUMENT_FRAGMENT_NODE=11
  12. Node.NOTATION_NODE=12

2. nodeName和nodeValue属性：
对于元素节点，nodeName中保存的始终都是元素的标签名，而nodeValue的值始终为null。

3. 节点关系
每个节点都有一个childNodes属性，其中保存着一个NodeList对象，NodeList是一种类数组对象，用于保存一组有序节点，可以通过位置来访问这些节点，但它并不是Array的实例。DOM结构的变化能够自动反映在NodeList对象中。
每个节点都有一个parentNode属性，该节点指向文档树中的父节点。包含在childNodes中的节点具有相同的父节点，每个节点之间是同胞节点，可以通过previousSilbling和nextSibling属性访问。
hasChildNodes()方法在节点包含一个或多个子节点的情况下返回true。
所有节点都有的一个属性是ownerDocument，该属性指向表示整个文档的文档节点。

4. 操作节点
appendChild()方法用于向childNodes列表的末尾添加一个节点，返回值为新增的节点。
insertBefore()将节点放在列表中某个特定的位置上。
replaceChild()替换列表中某节点，并且返回被替换掉并从列表中移除的节点。
removeChild()移除节点，并返回被移除的节点。

5. 其他方法
cloneNode()方法用于创建节点副本，传入参数true表示执行深度复制（复制节点及整个子节点树），false执行浅复制（只复制节点本身）。
normalize()方法处理文档树中的文本节点。当某个节点调用它时就会在该节点的子节点中查找，如果找到了空文本节点，则删除它，如果找到相邻节点，则将他们合并成一个节点。

**Document类型**

在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例。
Document节点特征：
- nodeType值为9
- nodeName值为"#document"
- nodeValue、parentNode、ownerDocument值为null
- 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。

1. 文档子节点
内置访问子节点快捷方式：
	- document.documentElement属性始终指向HTML页面中的<html>元素
	- document.body属性直接指向<body>元素

2. 文档信息
title属性
URL属性：包含页面完整的URL
domain属性：只包含页面的域名，可以设置，但不能将其设置为URL中不包含的域
referrer属性保存着链接到当前页面的那个页面的URL

3. 查找元素
getElementById()
getElementByTagName()，返回一个HTMLCollection对象，与NodeList对象类似，可以通过下标（方括号）或item()方法取得其中值，如果包含name属性，也可以通过namedItem()方法取得。
getElementByName()，常用取得单选按钮。

4. 特殊集合

5. DOM一致性检测
document.implementation.hasFeature("XML", "1.0")，返回true或者false。

6. 文档写入
write()、writeln()、open()、close()。

**Element类型**

在HTML中，标签名（tagName）始终都以全部大写表示。
1. HTML元素
标准特性：
id、title、lang、dir、className
2. 取得特性
getAttribute()、setAttribute()、removeAttribute()。
两类特殊属性虽然有对应属性名，但属性的值与通过getAttribute()返回的并不同。第一类特性就是style，第二类特性是onclick这样的事件处理程序。
3. attributes属性
4. 创建元素
createElement()方法创建新元素，IE中可以直接传入标签来创建。
5. 元素子节点
Text类型
开始标签与结束标签之间只要存在内容，就会创建一个文本节点。
1. 创建文本节点
createTextNode()。
2. 规范化文本节点
normalize()方法，在包含两个或多个文本节点的父元素上调用normalize方法时，则会将所有文本节点合并成一个节点。
3. 分隔文本节点
splitText()方法与normalize()方法相反，按指定位置分隔nodeValue值，返回包含剩余部分的一个节点。
Comment类型
Comment类型与Text类型继承自相同的基类。
createComment()方法创建注释节点，浏览器不会识别位于< html>标签外的注释。
CDATASection类型
只针对于XML文档，继承自Text类型。
createCDataSection()方法来创建CDATA区域。
DocumentType类型
不常用，仅Firefox，Safari，Opera支持，浏览器会把DocumentType对象保存在document.doctype中，包括三个属性：name，entities，notations。
DocumentFragment类型
虽然不能把文档片段直接添加到文档中，但可以将它当做一个仓库来使用，即可以在里面保存将来可能会添加到 文档中的节点。
Attr类型
元素的特性在DOM中以Attr类型来表示，特性就是存在于attributes属性中的节点。
2、DOM操作技术
1. 动态脚本

## 第二十章 JSON

1、语法
JSON语法可以表示以下三种类型的值：
      ○ 简单值：可以在JSON中表示字符串（双引号）、数值、布尔值和null，不支持JS中的undefined
      ○ 对象：一组无序的键值对（对象属性名要加双引号）
      ○ 数组：一组有序的值列表（用中括号表示，不要末尾分号，与JS数组字面量表示类似）
2、解析与序列化
早期使用JS的eval()函数。
JSON对象有两个方法：
JSON.stringify();
JSON.parse();

## 第二十一章 Ajax与Comet

1、XMLHttpRequest对象
var xhr=createXHR(); //创建
xhr.open("get", "example.php", true); //准备发送
xhr.send(null); //发送
xhr.abort(); //取消发送
xhr对象具有readyState属性，取值如下：
- 0：未初始化。尚未调用open方法。
- 1：启动。已调用open，未调用send方法。
- 2：发送。已调用send方法，未接收到响应。
- 3：接收。已接收到部分数据。
- 4：完成。已接收到全部数据，而且已经可以在客户端使用了。

HTTP头部信息
setRequestHeader()方法设置自定义请求头部信息，接收两个参数，头部字段的名称和值，需在open之后，send之前调用该方法。
getResponseHeader()方法并传入头部字段名称可取得相应头部信息。
getAllResponseHeader()方法获取一个包含头部信息的长字符串。
GET请求
xhr.open("get", "example.php?name1=value1&name2=value2", true);
POST请求
xhr.open("get", "example.php", true);
send(data);
XMLHttpRequest 2级
- FormData类型
- 超时设定：timeout属性，ontimeout事件。
- overrideMimeType()方法

进度事件
- loadstart事件
- progress事件
- error事件
- abort事件
- load事件
- loadend事件

跨域资源共享
CORS（跨源资源共享）
- 设置请求头Origin
- 使用绝对地址
- 其他跨域技术：
  - 图像Ping（只能发送GET请求，无法访问服务器的响应文本）
  - JSONP（JSON with padding）（从其他域中加载代码执行，不安全，请求失败验证不容易）
  - Comet（长轮询，短轮询，定时发送数据；HTTP流，一次请求，定时发送）

服务器发送事件
- SSE（Server Send Events，服务器发送事件） API
- 事件流

Web Sockets
全双工、双向通信
建立连接取得响应后升级为Web Socket协议，URL的模式也不同，未加密http://变为
ws://，加密https://变为ws://。




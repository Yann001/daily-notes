> JavaScript高级程序设计学习笔记

[TOC]

## 第一章 JavaScript简介

## 第二章 在HTML中使用JavaScript

### 2.1 < script>元素

1. 延迟脚本（defer属性）：<script defer="defer"></script> 只适用于外部脚本文件，先加载，不执行，一般在</html>后，DOMContentLoaded事件之前执行，最好只包含一个延迟脚本。
2. 异步脚本（async属性）：指定async 属性的目的是不让页面等待脚本下载和执行，也是只适用于外部脚本，从而异步加载页面其他内容，因此异步脚本不要在加载器件修改DOM。标记为async 的脚本并不保证按照指定它们的先后顺序执行


### 2.2 嵌入代码与外部文件

在HTML 中嵌入JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含JavaScript 代码。不过，并不存在必须使用外部文件的硬性规定，但支持使用外部文件的人多会强调如下优点。
- 可维护性：遍及不同HTML 页面的JavaScript 会造成维护问题。但把所有JavaScript 文件都放在一个文件夹中，维护起来就轻松多了。而且开发人员因此也能够在不触及HTML 标记的情况下，集中精力编辑JavaScript 代码。
- 可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript 文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。
- 适应未来：通过外部文件来包含JavaScript 无须使用前面提到XHTML 或注释hack。HTML 和XHTML 包含外部文件的语法是相同的。

### 2.3 文档模式

IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。最初的两种文档模式是：混杂模式（quirks mode）①和标准模式（standards mode）。混杂模式会让IE 的行为与（包含非标准特性的）IE5 相同，而标准模式则让IE 的行为更接近标准行为。虽然这两种模式主要影响CSS内容的呈现，但在某些情况下也会影响到JavaScript 的解释执行。
在IE 引入文档模式的概念后，其他浏览器也纷纷效仿。在此之后，IE 又提出一种所谓的准标准模式（almost standards mode）。这种模式下的浏览器特性有很多都是符合标准的，但也不尽然。不标准的地方主要体现在处理图片间隙的时候（在表格中使用图片时问题最明显）。
如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些hack 技术，跨浏览器的行为根本就没有一致性可言。
对于标准模式，可以通过使用下面任何一种文档类型来开启：
``` html
<!-- HTML 4.01 严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<!-- XHTML 1.0 严格型 -->
<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- HTML 5 -->
<!DOCTYPE html>
```

### 2.4 < noscript>元素

早期浏览器都面临一个特殊的问题，即当浏览器不支持JavaScript 时如何让页面平稳地退化。对这个问题的最终解决方案就是创造一个< noscript>元素，用以在不支持JavaScript 的浏览器中显示替代的内容。这个元素可以包含能够出现在文档< body>中的任何HTML 元素< script>元素除外。包含在< noscript>元素中的内容只有在下列情况下才会显示出来：

- 浏览器不支持脚本
- 浏览器支持脚本，但脚本被禁用

## 第三章 基本概念

### 语法

1. 区分大小写
2. 标识符：第一个字母为字母、下划线或美元符$。驼峰式命名（getElementById）。
3. 注释：单行//  块级注释（多行）/* 开头 */结尾。
4. 严格模式：脚本中添加 "use strict"。
5. 语句：推荐末尾加分号，尽量使用代码块（使用{}将代码括起来），哪怕if语句后只有一句代码。
6. 变量：使用 var 关键字定义，未初始化时会保存一个特殊的值--undefined，在修改变量值得同时可以修改变量的类型，但不推荐，通过var定义的变量是局部变量。省略var关键字课定义全局变量，但不推荐。

### 数据类型

ECMAScript中有5种简单数据类型：Undefined、Null、Boolean、Number、String。1种复杂数据类型Object。

#### typeof 操作符

typeof操作符（不是函数，可以不要()）：返回下列某个字符串

- "undefined"--如果值未定义
- "boolean"--如果值是布尔值
- "string"--如果值是字符串
- "number"--如果值是数值
- "object"--如果值是对象或null
- "function"--如果值是函数


#### Undefined类型

Undefined类型只有一个值，即特殊的undefined。对于声明未进行初始化或未进行声明的变量使用typeof操作符都会返回"undefined"。

#### Null类型

Null类型，也只有一个值null（逻辑上看表示一个空对象指针），实际上undefined是派生自null的对它们使用==符号判断时会返回true。

#### Boolean类型

Boolean类型，只有true和false两个值。
可以对任何数据类型的值调用Boolean()函数
对应返回值如下：

|数据类型|返回true|返回false|
|--|--|--|
|Boolean|true|false|
|String|任何非空字符串|""（空字符串）|
|Number|任何非零数字值（包括无穷大）|0和NaN|
|Object|任何对象|Null|
|Undefined|N/A（not applicable）不适用|undefined|

#### Number类型

- 十进制
- 八进制（0开头，如果后面包含大于7的数字，则会忽略0，直接解析成十进制数）
- 十六进制（0x开头，后面字母可大写可小写）。

在进行算数运算时，最终都将转换成十进制数值。可以保存正零（+0）和负零（-0），正零和负零被认为相等。

**浮点数值：**

- 数值中必须包含一个小数点，并且小数点后面至少有一位数字。
- 可以用e/E表示法（科学计数法）表示数值。
- 浮点数的最高精度是17位小数。
- 默认情况下，ECMAScript会将小数点后面带有6个零以上的数值转换成e表示法表示的数值。

**数值范围：**

- ECMAScript表示的最大值保存在Number.MAX_VALUE中，最小值保存在Number.MIN_VALUE中
- 超出范围将会自动转换成特殊值+Infinity或-Infinity，可以使用isFinite函数判断一个数值是否是有穷的。

**NaN**

NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数
未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0 都会导致错误，
从而停止代码执行。但在ECMAScript 中，任何数值除以0会返回一个值（0/0返回NaN，正数/0返回Infinity，负数/0返回-Infinity），因此不会影响其他代码的执行。

**数值转换：**

Number()、parseInt()、parseFloat()。

Number()函数的转换规则如下。

- 如果是Boolean 值，true 和false 将分别被转换为1 和0。
- 如果是数字值，只是简单的传入和返回。
- 如果是null 值，返回0。
- 如果是undefined，返回NaN。
- 如果是字符串，遵循下列规则：
    - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成1，"123"会变成123，而"011"会变成11（注意：前导的零被忽略了）；
    - 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）；
    - 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
    - 如果字符串是空的（不包含任何字符），则将其转换为0；
    - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。
- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。

parseInt(val[, 10|16|8|2])参数解析

- val为带转化为数字的值
- 第二个参数为可选参数，表示按几进制进行数值的解析，不传递则按照十进制进行解析

#### String类型

字符串可以由双引号（"）或单引号（'）表示，用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。

**1. 字符字面量**

String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示：

|字面量|含义|
|--|--|
|\n|换行|
|\t|制表|
|\b|空格|
|\r|回车|
|\f|进纸|
|\\|斜杠|
|\'|单引号（'）（'），在用单引号表示的字符串中使用。例如：'He said, \'hey.\''|
|\"|双引号（"）（"），在用双引号表示的字符串中使用。例如："He said, \"hey.\""|
|\xnn|以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示"A"|
|\unnnn|以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ|

** 2. 字符串的特点**

ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，
例如：

``` js
var lang = "Java";
lang = lang + "Script";
```

以上示例中的变量lang 开始时包含字符串"Java"。而第二行代码把lang 的值重新定义为"Java"与"Script"的组合，即"JavaScript"。实现这个操作的过程如下：首先创建一个能容纳10 个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字符串"Script"，因为这两个字符串已经没用了。

**3. 转换为字符串**

要把一个值转换为一个字符串的方法有两个:

- toString()方法
- String()方法。

也可使用加号操作符+把它与一个字符串""连在一起。

数值、布尔值、对象和字符串值（每个字符串也都有一个toString()方法，该方法返回字
符串的一个副本）都有toString()方法。但null 和undefined 值没有这个方法。

多数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。如：

``` js
var num = 10;
alert(num.toString()); // "10"
alert(num.toString(2)); // "1010"
alert(num.toString(8)); // "12"
alert(num.toString(10)); // "10"
alert(num.toString(16)); // "a"
```

在不知道要转换的值是不是null 或undefined 的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则：

- 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；
- 如果值是null，则返回"null"；
- 如果值是undefined，则返回"undefined"。

#### Object类型

Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。
Object 的每个实例都具有下列属性和方法。

- constructor，保存着用于创建当前对象的函数。
- hasOwnProperty(propertyName)，用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty("name")）。
- isPrototypeOf(object)，用于检查传入的对象是否是传入对象的原型。
- propertyIsEnumerable(propertyName)，用于检查给定的属性是否能够使用for-in 语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
- toLocaleString()，返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString()，返回对象的字符串表示。
- valueOf()，返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。

从技术角度讲，ECMA-262 中对象的行为不一定适用于JavaScript 中的其他对象。浏览器环境中的对象，比如BOM 和DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。

### 操作符

#### 一元操作符

只能操作一个值的操作符叫做一元操作符。

**1. 递增和递减操作符**

- 前置型 ++i, --i (副效应)
- 后置型 i++, i--

所有这4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。

- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1 的操作。字符串变量变成数值变量。
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN，字符串变量变成数值变量。
- 在应用于布尔值false 时，先将其转换为0 再执行加减1 的操作。布尔值变量变成数值变量。
- 在应用于布尔值true 时，先将其转换为1 再执行加减1 的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时，执行加减1 的操作。
- 在应用于对象时，先调用对象的valueOf()方法，以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。

示例：

``` js
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
  return -1;
  }
};
s1++; // 值变成数值3
s2++; // 值变成NaN
b++; // 值变成数值1
f--; // 值变成0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值-2
```

**2. 一元加和减操作符**

一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响。不过，在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。换句话说，布尔值false 和true 将被转换为0 和1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的valueOf()和（或）toString()方法，再转换得到的值。

示例：

``` js
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
  return -1;
  }
};
s1 = +s1; // 值变成数值1
s2 = +s2; // 值变成数值1.1
s3 = +s3; // 值变成NaN
b = +b; // 值变成数值0
f = +f; // 值未变，仍然是1.1
o = +o; // 值变成数值-1
```

一元减操作符主要用于表示负数，例如将1 转换成-1。当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数

示例：

``` js
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
  return -1;
  }
};
s1 = -s1; // 值变成了数值-1
s2 = -s2; // 值变成了数值-1.1
s3 = -s3; // 值变成了NaN
b = -b; // 值变成了数值0
f = -f; // 变成了-1.1
o = -o; // 值变成了数值1
```

一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。

#### 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位

**1. 按位非（NOT）**

按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。
如：

``` js
var num1 = 25; // 二进制00000000000000000000000000011001
var num2 = ~num1; // 二进制11111111111111111111111111100110
alert(num2); // -26
```

**2. 按位与（AND）**

按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位与操作就是将两个数值的每一位对齐，对相同位置上的两个数执行AND操作。
按位与操作只在两个数值的对应位都是1 时才返回1，任何一位是0，结果都是0。

**3. 按位或（OR）**

按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。
按位或操作在有一个位是1 的情况下就返回1，而只有在两个位都是0 的情况下才返回0。

**4. 按位异或（XOR）**

按位异或操作符由一个插入符号（^）表示，也有两个操作数。
这个操作在两个数值对应位上只有一个1 时才返回1，如果对应的两位都是1 或都是0，则返回0。

**5. 左移**

左移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，如果将数值2（二进制码为10）向左移动5 位，结果就是64（二进制码为1000000）。
注意，在向左移位后，原数值的右侧多出了5 个空位。左移操作会以0 来填充这些空位，以便得到的结果是一个完整的32位二进制数。

**6. 有符号的右移**

有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记）。

**7. 无符号右移**

无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移相同，但是对负数来说，情况就不一样了。首先，无符号右移是以0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。

#### 布尔操作符

**1. 逻辑非**

逻辑非操作符由一个叹号（！）表示，可以应用于ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。也就是说，逻辑非操作符遵循下列规则：

- 如果操作数是一个对象，返回false；
- 如果操作数是一个空字符串，返回true；
- 如果操作数是一个非空字符串，返回false；
- 如果操作数是数值0，返回true；
- 如果操作数是任意非0 数值（包括Infinity），返回false；
- 如果操作数是null，返回true；
- 如果操作数是NaN，返回true；
- 如果操作数是undefined，返回true。

**2. 逻辑与**

逻辑与操作符由两个和号（&&）表示，有两个操作数，逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第二个操作数；
- 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true 的情况下才会返回该
- 对象；
- 如果两个操作数都是对象，则返回第二个操作数；
- 如果有一个操作数是null，则返回null；
- 如果有一个操作数是NaN，则返回NaN；
- 如果有一个操作数是undefined，则返回undefined。

逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。

**3. 逻辑或**

逻辑或操作符由两个竖线符号（||）表示，有两个操作数，与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值；此时，它遵循下列规则：

- 如果第一个操作数是对象，则返回第一个操作数；
- 如果第一个操作数的求值结果为false，则返回第二个操作数；
- 如果两个操作数都是对象，则返回第一个操作数；
- 如果两个操作数都是null，则返回null；
- 如果两个操作数都是NaN，则返回NaN；
- 如果两个操作数都是undefined，则返回undefined。

与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

#### 乘性操作符

**1. 乘法**

乘法操作符由一个星号（*）表示，用于计算两个数值的乘积。
在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：

- 如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript 数值的表示范围，则返回Infinity 或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 与0 相乘，则结果是NaN；
- 如果是Infinity 与非0 数值相乘，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity 与Infinity 相乘，则结果是Infinity；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

**2. 除法**

除法操作符由一个斜线符号（/）表示，执行第二个操作数除第一个操作数的计算

与乘法操作符类似，除法操作符对特殊的值也有特殊的处理规则。这些规则如下：

- 如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript 数值的表示范围，则返回Infinity 或-Infinity；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 被Infinity 除，则结果是NaN；
- 如果是零被零除，则结果是NaN；
- 如果是非零的有限数被零除，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果是Infinity 被任何非零数值除，则结果是Infinity 或-Infinity，取决于有符号操作数的符号；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

**3. 求模**
求模（余数）操作符由一个百分号（%）表示
与另外两个乘性操作符类似，求模操作符会遵循下列特殊规则来处理特殊的值：

- 如果操作数都是数值，执行常规的除法计算，返回除得的余数；
- 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN；
- 如果被除数是有限大的数值而除数是零，则结果是NaN；
- 如果是Infinity 被Infinity 除，则结果是NaN；
- 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；
- 如果被除数是零，则结果是零；
- 如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的规则。

#### 加性操作符

**1. 加法**

如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：

- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 加Infinity，则结果是Infinity；
- 如果是-Infinity 加-Infinity，则结果是-Infinity；
- 如果是Infinity 加-Infinity，则结果是NaN；
- 如果是+0 加+0，则结果是+0；
- 如果是-0 加-0，则结果是-0；
- 如果是+0 加-0，则结果是+0；
- 如果有一个操作数是字符串，那么就要应用如下规则：
  - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。
- 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined 和null，则分别调用String()函数并取得字符串"undefined"和"null"。

**2. 减法**

与加法操作符类似，ECMAScript 中的减法操作符在处理各种数据类型转换时，同样需要遵循一些特殊规则，如下所示：

- 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果；
- 如果有一个操作数是NaN，则结果是NaN；
- 如果是Infinity 减Infinity，则结果是NaN；
- 如果是-Infinity 减-Infinity，则结果是NaN；
- 如果是Infinity 减-Infinity，则结果是Infinity；
- 如果是-Infinity 减Infinity，则结果是-Infinity；
- 如果是+0 减+0，则结果是+0；
- 如果是+0 减-0，则结果是-0；
- 如果是-0 减-0，则结果是+0；
- 如果有一个操作数是字符串、布尔值、null 或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；
- 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

#### 关系操作符

小于（<）、大于（>）、小于等于（<=）和大于等于（>=）这几个关系操作符用于对两个值进行比较，比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值

与ECMAScript 中的其他操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作。以下就是相应的规则。

- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。
- 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
- 任何操作数与NaN 进行关系比较，结果都是false。

#### 相等操作符

**1. 相等和不相等**

ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回true。而不相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回true。这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

- 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为0，而true 转换为1；
- 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
- 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；
- 这两个操作符在进行比较时则要遵循下列规则。
  - null 和undefined 是相等的。
  - 要比较相等性之前，不能将null 和undefined 转换成其他任何值。
- 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN 不等于NaN。
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

**2. 全等和不全等**

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。

#### 条件操作符

``` js
variable = boolean_expression ? true_value : false_value;
```

这行代码的含义就是基于对boolean_expression 求值的结果，决定给变量variable赋什么值。如果求值结果为true，则给变量variable 赋true_value 值；如果求值结果为false，则给变量variable 赋false_value 值。

#### 赋值操作符

简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量。
如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。
每个主要算术操作符（以及个别的其他操作符）都有对应的复合赋值操作符。这些操作符如下所示：

- 乘/赋值（*=）；
- 除/赋值（/=）；
- 模/赋值（%=）；
- 加/赋值（+=）；
- 减/赋值（-=）；
- 左移/赋值（<<=）；
- 有符号右移/赋值（>>=）；
- 无符号右移/赋值（>>>=）。

设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。

#### 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示：
``` js
var num1=1, num2=2, num3=3;
```

逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示：
``` js
var num = (5, 1, 4, 8, 0); // num 的值为0
```

由于0 是表达式中的最后一项，因此num 的值就是0。虽然逗号的这种使用方式并不常见，但这个例子可以帮我们理解逗号的这种行为。


### 语句

语句：

- if else
- do while
- while
- for（由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在循环外部访问）
- for in
- label（label:statement）
- with（不建议使用，严格模式下不允许）
- switch

ECMAScript 对象的属性没有顺序。因此，通过for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。
但是，如果表示要迭代的对象的变量值为null 或undefined，for-in 语句会抛出错误。ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in 循环之前，先检测确认该对象的值不是null 或undefined。


### 函数

return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。比如在下面这个例子中，就不会显示警告框：
``` js
function sayHi(name, message) {
  return;
  alert("Hello " + name + "," + message); //永远不会调用
}
```

严格模式对函数有一些限制：

- 不能把函数命名为eval 或arguments；
- 不能把参数命名为eval 或arguments；
- 不能出现两个命名参数同名的情况。

如果发生以上情况，就会导致语法错误，代码无法执行。

**函数：arguments对象**

- arguments对象是一个类数组对象，可通过下标访问其属性，也具有length属性，但其并不是Array的实例
- 函数中可以使用arguments对象访问参数
- arguments[index]可与参数名混用
- 没有传递值得命名参数将自动被赋予undefined值
- 严格模式对如何使用arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。重写arguments 的值会导致语法错误（代码将不会执行）。

**ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。**

**ECMAScript 函数没有重载**

定义命名相同的两个函数时，后定义的函数将会覆盖之前定义的函数。


## 第四章 变量、作用域和内存问题

### 基本类型和引用类型的值

**1. 动态属性**

只能给引用类型值动态添加属性

**2. 复制变量值**

复制基本类型值时会创建独立的副本，但复制引用类型的值时两个变量将引用同一个对象。

**3. 传递参数**

所有函数的参数都是按照值传递的。

**4. 检测类型**

- typeof
- instanceof

### 执行环境及作用域

执行环境（execution context，为简单起见，有时也称为“环境”）是JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境。根据ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web 浏览器中，全局执行环境被认为是window 对象（第7 章将详细讨论），因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。
当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。

Web浏览器中，全局执行环境被认为是windows对象。
内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

**延长作用域链**

- 当执行流进入下列任何一个语句时，作用域链就会得到加长：
- try-catch语句的catch块
- with语句

对with 语句来说，会将指定的对象添加到作用域链中。
对catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

**没有块级作用域**

- 声明变量：如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中。严格模式下，不声明会导致错误。
- 查询标识符：作用域链逐级向上搜索。
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。


### 垃圾收集

1. 标记清除（常用）
2. 引用计数
3. 性能问题（垃圾收集器周期运行）
4. 管理内存
使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，

## 第五章 引用类型

用类型的值（对象）是引用类型的一个实例。在ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
虽然引用类型与类看起来相似，但它们并不是相同的概念。

ECMAScript提供了很多原生引用类型,如：

- Object
- Array

### Object类型

**对象创建**

- var obj = new Object()，new操作符后跟Object构造函数形式
- var obj = {}，对象字面量方式

*在通过对象字面量定义对象时，实际上不会调用Object构造函数（Firefox2及更早版本会调用Object构造函数；但Firefox3之后就不会了）。*

**访问属性**

- `.`
- `[]`

对象属性名中是可以包含非字母非数字的，有时不能用点号方式访问时就用方括号形式，或属性是变量时也用方括号形式。一般建议用点号方式。

### Array类型

**创建**

- 构造函数，var arr = new Array()或new Array(10)或new Array('red', 'green', 'blue')，其中new可以省略，效果一样。
- 字面量形式，var arr = [];

数组最多可以包含4 294 967 295 个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。

#### 检测数组

- instance of
- Array.isArray()

value instanceof Array 会因存在两个或以上的全局环境出现问题，ECMAScript 5新增了Array.isArray(value)方法，检测值value是不是数组。

#### 转换方法

- toString()，返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串
- valueOf()，返回的还是数组
- toLocaleString()，toLocaleString()方法经常也会返回与toString()和valueOf()方法相同的值
- join(),可以使用不同的分隔符来构建数组toString()的字符串

#### 栈方法

- push()，可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
- pop()，从数组末尾移除最后一项，减少数组的length 值，然后返回移除的项。

#### 队列方法

- shift()，移除数组中的第一个项并返回该项，同时将数组长度减1。
- unshift，在数组前端添加任意个项并返回新数组的长度。

#### 重排序方法

- reverse()，反转数组项的顺序。
- sort()，在默认情况下，sort()方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。

sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。

**reverse()和sort()方法的返回值是经过排序之后的数组，由于数组是引用类型，两个方法都会改变原数组，如果不想改变原数组，可将原数组深拷贝（可用数组concat或slice方法）一份再对副本进行操作。**




#### 操作方法

- concat()，，concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。
- slice()，它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。

*注意，slice()方法不会影响原始数组。方法返回数组中的某一段，如果该方法中包含负数，则用数组长度加上该数来确定位置，结束位置小于起始位置时返回空数组。*

- splice()方法
  - 删除，可以删除任意数量的项，只需指定2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。
  - 插入，可以向指定位置插入任意数量的项，只需提供3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。
  - 替换，可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

*splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）*


#### 位置方法

- indexOf()
- lastIndexOf()方法，返回要查找的项在数组中第一次出现位置的索引值。

这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回.1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）

#### 迭代方法

ECMAScript 5 为数组定义了5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5 个迭代方法的作用。

- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。
- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

**以上方法都不会修改数组中的包含的值。**

#### 归并方法

- reduce()
- reduceRight()

ECMAScript 5 还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。
这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。



### Date类型

ECMAScript 中的Date 类型是在早期Java 中的java.util.Date 类基础上构建的。为此，Date类型使用自UTC（Coordinated Universal Time，国际协调时间）1970 年1 月1 日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date 类型保存的日期能够精确到1970 年1月1 日之前或之后的285 616 年。

要创建一个日期对象，使用new 操作符和Date 构造函数即可，如下所示。
``` js
var now = new Date();
```

在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC 时间1970 年1 月1 日午夜起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript 提供了两个方法：

- Date.parse()
- Date.UTC()

Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262 没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。
将地区设置为美国的浏览器通常都接受下列日期格式：

- “月/日/年”，如 6/13/2004
- “英文月名 日,年”，如 January 12,2004
- “英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700
- ISO 8601 扩展格式YYYY-MM-DDTHH:mm:ss.sssZ，如 （2004-05-25T00:00:00），只有兼容ECMAScript 5 的实现支持这种格式。

例如，要为2004 年5 月25 日创建一个日期对象，可以使用下面的代码：
``` js
var someDate = new Date(Date.parse("May 25, 2004"));
```

如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date 构造函数，也会在后台调用Date.parse()。换句话说，下面的代码与前面的例子是等价的：
``` js
var someDate = new Date("May 25, 2004");
```

这行代码将会得到与前面相同的日期对象。

Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于0 的月份（一月是0，二月是1，以此类推）、月中的哪一天（1 到31）、小时数（0 到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。
以下是两个使用Date.UTC()方法的例子：
``` js
// GMT 时间2000 年1 月1 日午夜零时
var y2k = new Date(Date.UTC(2000, 0));
// GMT 时间2005 年5 月5 日下午5:55:55
var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
```

如同模仿Date.parse()一样，Date 构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT 来创建。不过，Date 构造函数接收的参数仍然与Date.UTC()相同。
因此，如果第一个参数是数值，Date 构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。据此，可以将前面的例子重写如下。
``` js
// 本地时间2000 年1 月1 日午夜零时
var y2k = new Date(2000, 0);
// 本地时间2005 年5 月5 日下午5:55:55
var allFives = new Date(2005, 4, 5, 17, 55, 55);
```

以上代码创建了与前面例子中相同的两个日期对象，只不过这次的日期都是基于系统设置的本地时区创建的。

**Date.now()**

ECMAScript 5 添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。

#### 继承的方法

- toString()
- toLocaleString()
- valueOf()

Date 类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM 或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0 到23）表示。
这两个方法在不同的浏览器中返回的日期和时间格式可谓大相径庭。事实上，toLocaleString()和toString()的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。
至于Date 类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值。

#### 日期格式化方法

Date 类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。

- toDateString()——以特定于实现的格式显示星期几、月、日和年；
- toTimeString()——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
- toUTCString()——以特定于实现的格式完整的UTC 日期。

与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

除了前面介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript 推荐现在编写的代码一律使用toUTCString()方法。

#### 日期/事件组件方法

还有部分Date 类型的方法（如下表所示），都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC 日期指的是在没有时区偏差的情况下（将日期转换为GMT 时间）的日期值。

|方法|说明|
|--|--|
|getTime() |返回表示日期的毫秒数；与valueOf()方法返回的值相同
|setTime(毫秒) |以毫秒数设置日期，会改变整个日期
|getFullYear() |取得4位数的年份（如2007而非仅07）
|getUTCFullYear() |返回UTC日期的4位数年份
|setFullYear(年) |设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
|setUTCFullYear(年) |设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
|getMonth() |返回日期中的月份，其中0表示一月，11表示十二月
|getUTCMonth() |返回UTC日期中的月份，其中0表示一月，11表示十二月
|setMonth(月) |设置日期的月份。传入的月份值必须大于0，超过11则增加年份
|setUTCMonth(月) |设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
|getDate() |返回日期月份中的天数（1到31）
|getUTCDate() |返回UTC日期月份中的天数（1到31）
|setDate(日) |设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
|setUTCDate(日) |设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
|getDay() |返回日期中星期的星期几（其中0表示星期日，6表示星期六）
|getUTCDay() |返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）
|getHours() |返回日期中的小时数（0到23）
|getUTCHours() |返回UTC日期中的小时数（0到23）
|setHours(时) |设置日期中的小时数。传入的值超过了23则增加月份中的天数
|setUTCHours(时) |设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
|getMinutes() |返回日期中的分钟数（0到59）
|getUTCMinutes() |返回UTC日期中的分钟数（0到59）
|setMinutes(分) |设置日期中的分钟数。传入的值超过59则增加小时数
|setUTCMinutes(分) |设置UTC日期中的分钟数。传入的值超过59则增加小时数
|getSeconds() |返回日期中的秒数（0到59）
|getUTCSeconds() |返回UTC日期中的秒数（0到59）
|setSeconds(秒) |设置日期中的秒数。传入的值超过了59会增加分钟数
|setUTCSeconds(秒) |设置UTC日期中的秒数。传入的值超过了59会增加分钟数
|getMilliseconds() |返回日期中的毫秒数
|getUTCMilliseconds() |返回UTC日期中的毫秒数
|setMilliseconds(毫秒) |设置日期中的毫秒数
|setUTCMilliseconds(毫秒) |设置UTC日期中的毫秒数
|getTimezoneOffset() |返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化



### RegExp类型

ECMAScript 通过RegExp 类型来支持正则表达式。使用下面类似Perl 的语法，就可以创建一个正则表达式。
``` js
var expression = / pattern / flags;
var regexp = new RegExp(pattern, flags);
```

其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
正则表达式的匹配模式支持下列3个标志:

- **g**：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- **i**：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- **m**：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：
`( ) [ ] { } + * ^ $ | \ . ?`
这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。

要注意的是，传递给RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp 构造函数）。由于RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n（字符\在字符串中通常被转义为\\，而在正则表达式字符串中就会变成\\\\）。下表给出了一些模式，左边是这些模式的字面量形式，右边是使用RegExp 构造函数定义相同模式时使用的字符串。

|字面量形式|等价字符串|
|--|--|
|/\[bc\]at/| "\\[bc\\]at"|
|/\.at/ "\\|.at"|
|/name\/age/| "name\\/age"|
|/\d.\d{1,2}/| "\\d.\\d{1,2}"|
|/\w\\hello\\123/| "\\w\\\\hello\\\\123"|

使用正则表达式字面量和使用RegExp 构造函数创建的正则表达式不一样。在ECMAScript 3 中，正则表达式字面量始终会共享同一个RegExp 实例，而使用构造函数创建的每一个新RegExp 实例都是一个新实例。来看下面的例子。

``` js
var re = null, i;
for (i=0; i < 10; i++) {
  re = /cat/g;
  re.test("catastrophe");
}
for (i=0; i < 10; i++) {
  re = new RegExp("cat", "g");
  re.test("catastrophe");
}
```

在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp 实例。由于实例属性（下一节介绍实例属性）不会重置，所以在循环中再次调用test()方法会失败。这是因为第一次调用test()找到了"cat"，但第二次调用是从索引为3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就又从开头开始了。第二个循环使用RegExp 构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp 实例，所以每次调用test()都会返回true。
ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用RegExp 构造函数一样，每次都创建新的RegExp 实例。IE9+、Firefox 4+和Chrome 都据此做出了修改。

#### RegExp实例属性

- RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- global：布尔值，表示是否设置了g 标志。
- ignoreCase：布尔值，表示是否设置了i 标志。
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0 算起。
- multiline：布尔值，表示是否设置了m 标志。
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。

#### RegExp实例方法

**1. exec() 方法**

RegExp 对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。
如下面例子：

``` js
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi;

var matches = pattern.exec(text);

alert(matches.index); // 0
alert(matches.input); // "mom and dad and baby"
alert(matches[0]); // "mom and dad and baby"
alert(matches[1]); // " and dad and baby"
aler t(matches[2]); // " and baby"
```

这个例子中的模式包含两个捕获组。最内部的捕获组匹配"and baby"，而包含它的捕获组匹配"anddad"或者"and dad and baby"。当把字符串传入exec()方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组matchs 的index 属性值为0。数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。

``` js
var text = "cat, bat, sat, fat";
var pattern1 = /.at/;

var matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0

matches = pattern1.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern1.lastIndex); //0


var pattern2 = /.at/g;
var matches = pattern2.exec(text);
alert(matches.index); //0
alert(matches[0]); //cat
alert(pattern2.lastIndex); //3

matches = pattern2.exec(text);
alert(matches.index); //5
alert(matches[0]); //bat
alert(pattern2.lastIndex); //8
```

这个例子中的第一个模式pattern1 不是全局模式，因此每次调用exec()返回的都是第一个匹配项（"cat"）。而第二个模式pattern2 是全局模式，因此每次调用exec()都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的lastIndex 属性的变化情况。在全局匹配模式下，lastIndex 的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。

*IE 的JavaScript 实现在lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex 属性每次也会变化。*

**2. test() 方法**

正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。

**3. 继承方法**

RegExp 实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。正则表达式的valueOf()方法返回正则表达式本身。

#### RegExp构造函数属性

TODO...

#### 模式的局限性

TODO...


### Function类型

函数实际上是对象。每个函数都是Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

**函数定义**

``` js
// 方式一 函数声明形式
function sum (num1, num2) {
  return num1 + num2;
}
//方式二 函数表达式形式
var sum = function(num1, num2){
  return num1 + num2;
};
// 方式三 构造函数形式
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。
由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字，如下面的例子所示。
``` js
function sum(num1, num2){
  return num1 + num2;
}
alert(sum(10,10)); //20
var anotherSum = sum;
alert(anotherSum(10,10)); //20
sum = null;
alert(anotherSum(10,10)); //20
```

以上代码首先定义了一个名为sum()的函数，用于求两个值的和。然后，又声明了变量anotherSum，并将其设置为与sum 相等（将sum 的值赋给anotherSum）。注意，使用不带圆括号的函数名是访问函数指针，而非调用函数。此时，anotherSum 和sum 就都指向了同一个函数，因此anotherSum()也可以被调用并返回结果。即使将sum 设置为null，让它与函数“断绝关系”，但仍然可以正常调用anotherSum()。

#### 没有重载


#### 函数声明与函数表达式

**区别**

解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

*也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari 中会导致错误。*

#### 作为值的函数

因为ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。

#### 函数内部属性

两个特殊对象：arguments和this。

- arguments主要用途是保存函数参数，还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
- this引用的是函数执行的环境对象，当在网页的全局作用域中调用函数时，this对象引用的就是windows。

ECMAScript 5 也规范化了另一个函数对象的属性：caller。除了Opera 的早期版本不支持，其他浏览器都支持这个ECMAScript 3 并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null

#### 函数的属性和方法

函数是一个对象，每个函数都包含两个属性：length和prototype。

- length属性表示函数希望接受的命名参数的个数。
- prototype，对于ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype 名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的。在ECMAScript 5 中，prototype 属性是不可枚举的，因此使用for-in 无法发现。


每个函数都包含两个非继承而来的方法：

- apply()
- call()

这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this 对象的值。
apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象
例如：
``` js
function sum(num1, num2){
  return num1 + num2;
}
function callSum1(num1, num2){
  return sum.apply(this, arguments); // 传入arguments 对象
}
function callSum2(num1, num2){
  return sum.apply(this, [num1, num2]); // 传入数组
}
alert(callSum1(10,10)); //20
alert(callSum2(10,10)); //20
```

在上面这个例子中，callSum1()在执行sum()函数时传入了this 作为this 值（因为是在全局作用域中调用的，所以传入的就是window 对象）和arguments 对象。而callSum2 同样也调用了sum()函数，但它传入的则是this 和一个参数数组。这两个函数都会正常执行并返回正确的结果。

*在严格模式下，未指定环境对象而调用函数，则this 值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是undefined。*

call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。
``` js
function sum(num1, num2){
  return num1 + num2;
}
function callSum(num1, num2){
  return sum.call(this, num1, num2);
}
alert(callSum(10,10)); //20
```

在使用call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）

事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。
``` js
window.color = "red";
var o = { color: "blue" };
function sayColor(){
  alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```

这个例子是在前面说明this 对象的示例基础上修改而成的。这一次，sayColor()也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示"red"——因为对this.color 的求值会转换成对window.color 的求值。而sayColor.call(this)和sayColor.call(window)，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示"red"。但是，当运行sayColor.call(o)时，函数的执行环境就不一样了，因为此时函数体内的this 对象指向了o，于是结果显示的是"blue"。

使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在一般的写法中，我们是先将sayColor()函数放到对象o 中，然后再通过o 来调用它的；而在这里重写的例子中，就不需要这个多余的步骤了。

ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值。例如：
``` js
window.color = "red";
var o = { color: "blue" };
function sayColor(){
  alert(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor(); //blue
```

在这里，sayColor()调用bind()并传入对象o，创建了objectSayColor()函数。objectSayColor()函数的this 值等于o，因此即使是在全局作用域中调用这个函数，也会看到"blue"。

每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf()方法同样也只返回函数代码。

### 基本包装类型


三个特殊的引用类型：

- Boolean
- Number
- String。


引用类型与基本包装类型的主要区别就是对象的生存期。

#### Boolean类型

布尔表达式中的所有对象都会被转成true

#### Number类型

toFixed()（四舍五入）、toExponential()（e表示法）、toPrecision()方法（自动选择合适方法）。

#### String类型

字符方法：charAt()、charCodeAt()。
字符串操作方法：concat()、slice()、substr()、substring()。
字符串位置方法：indexOf()、lastIndexOf()。
trim()方法：删除前缀及后缀空格。
字符串大小写转换方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()。
字符串模式匹配方法：match()方法与RegExp的exec()方法相同，search()方法返回字符串中的第一个匹配项的索引，始终从字符串开头向后查找。replace()方法；split()方法。
localeCompare()方法：比较两个字符串并返回1、0或-1。
fromCharCode()方法：静态方法，接受字符编码转换成字符串，与charCodeAt()相反。

7. 单体内置对象

Global对象
  1. URI编码方法：
    - encodeURI()--替换空格；
    - encodeURIComponent()--替换所有非字母数字字符；
    - decodeURI()方法；
    - decodeURIComponent()方法。
  2. eval()方法：
  3. Global对象属性：特殊值，原声引用类型构造函数都是Global对象属性。
  4. window对象

Math对象
  1. 属性：大都是数学计算中可能会用到的一些特殊值
  2. min()和max()方法。
  3. 舍入方法：
    - Math.ceil()：向上舍入
    - Math.floor()：向下舍入
    - Math.round()：标准四舍五入
  4. random()方法
	5. 其他还包括一些完成简单或复杂计算的方法。

## 第六章 面向对象的程序设计

扩展知识：属性名前加下划线表示只能通过对象方法访问的属性（p141）

### 理解对象

#### 属性类型

ECMAScript 中有两种属性：数据属性和访问器属性。

**1. 数据属性**

数据属性有四个描述其行为的特性：

- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特型，或者能否把属性修改为访问器属性。默认值为true。
- [[Enumerable]]：表示能否通过for in 返回属性。默认值为true。
- [[Writable]]：表示能否修改属性的值。默认值为true。
- [[Value]]：包含这个属性的数据值。默认值为undefined。


要修改属性的默认特性（以上四个），必须使用ECMAScript5的Object.defineProperty()方法。该方法接收三个参数，属性所在对象、属性的名字和一个描述符对象（以上四个）。调用该方法时，如果不指定，四个特性的默认值都是false。
例如：

``` js
var person = {};
Object.defineProperty(person, "name", {
  writable: false,
  value: "Nicholas"
});
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
```
这个例子创建了一个名为name 的属性，它的值"Nicholas"是只读的。这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。



**2. 访问器属性**

访问器属性有四个特性：

- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特型，或者能否把属性修改为访问器属性。默认值为true。
- [[Enumerable]]：表示能否通过for in 返回属性。默认值为true。
- [[Get]]：在读取属性时调用的函数。默认值为undefined。
- [[Set]]：在写入属性时调用的函数。默认值为undefined。


访问器属性不能直接定义，必须使用Object.defineProperty()来定义。
如下面的例子：
``` js
var book = {
  _year: 2004,
  edition: 1
};
Object.defineProperty(book, "year", {
  get: function(){
    return this._year;
  },
  set: function(newValue){
    if (newValue > 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
});
book.year = 2005;
alert(book.edition); //2
```

以上代码创建了一个book 对象，并给它定义两个默认的属性：_year 和edition。_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。而访问器属性year 则包含一个getter 函数和一个setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此，把year 属性修改为2005 会导致_year 变成 2005，而edition 变为2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。
不一定非要同时指定getter 和setter。只指定getter 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter 函数的属性会抛出错误。类似地，只指定setter 函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。


#### 定义多个属性

Object.defineProperties()方法，第一个参数是要添加和修改其属性的对象，第二个与第一个对象中要添加或修改的属性一一对应。


#### 读取属性的特性

Object.getOwnPropertyDescriptor()方法，参数为属性所在对象和要读取属性的名称，返回值是一个对象。

### 创建对象


#### 工厂模式

用函数来封装已特定接口创建对象的细节。
构造函数模式

#### 原型模式

创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，
而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。

``` js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
  alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

在此，我们将sayName()方法和所有属性直接添加到了Person 的prototype 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和person2 访问的都是同一组属性和同一个sayName()函数。

**1. 理解原型对象**

无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype 属性所在函数的指针。就拿前面的例子来说，Person.prototype. constructor 指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。






创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
isPrototypeOf()方法
Object.getPrototypeOf()方法
hasOwnProperty()方法
原型与in操作符，只要能通过对象访问到属性就返回true，hasOwnProperty()只有属性存在于实例中时才返回true，因此只要in操作符返回true，而hasOwnProperty()返回false，就可以确定属性是原型中的属性。
Object.keys()方法取得对象上所有可以枚举的属性。
Object.getOwnPropertyNames()方法取得所有实例属性，包括不可枚举（constructor等）
原型的动态性
原生对象的原型
组合使用原型模式和构造函数模式
寄生构造函数模式
稳妥构造函数模式

### 继承

#### 原型链

#### 借用构造函数

#### 组合继承

#### 原型式继承

#### 寄生式继承

#### 寄生组合式继承




## 第七章 函数表达式

- 函数声明
- 函数表达式（匿名函数、拉姆达函数）


### 递归

arguments.callee是一个指向正在执行函数的指针。也可使用一个命名的函数表达式来实现。

### 闭包

#### 闭包与变量

#### 关于this对象

#### 内存泄漏

### 模仿块级作用域

``` js
(function (){
	//块级作用域
})();
```
函数表达式后面可以跟圆括号，而函数声明后面不能跟圆括号。

### 私有变量

#### 特权方法

有权访问私有变量的公有方法

#### 静态私有变量

####模块模式

如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。

#### 增强的模块模式


## 第八章 BOM

### 1. window对象

BOM对象的核心是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象、变量和函数，都以window 作为其Global 对象，因此有权访问parseInt()等方法。

#### 全局作用域

由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window 对象的属性和方法。

全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。
例如：
``` js
var age = 29;
window.color = "red";
//在IE < 9 时抛出错误，在其他所有浏览器中都返回false
delete window.age;
//在IE < 9 时抛出错误，在其他所有浏览器中都返回true
delete window.color; //returns true
alert(window.age); //29
alert(window.color); //undefined
```

尝试访问未声明的变量会出错，但可以通过查询window对象，可以知道某个可能未声明的变量是否存在。
例如：
``` js
//这里会抛出错误，因为oldValue 未定义
var newValue = oldValue;
//这里不会抛出错误，因为这是一次属性查询
//newValue 的值是undefined
var newValue = window.oldValue;
```

#### 窗口关系及框架

如果页面中包含框架，则每个框架都拥有自己的window 对象，并且保存在frames 集合中。在frames集合中，可以通过数值索引（从0 开始，从左至右，从上到下）或者框架名称来访问相应的window 对象。每个window 对象都有一个name 属性，其中包含框架的名称。

``` html
<frameset><frame></frame></frameset>
```
window.frames[0]、top.frames[0]、frames[0]。
parent，在没有框架的情况下parent一定等于top，它们都等于window。

#### 窗口位置

screenLeft和screenTop属性（screenX，screenY）。moveTo()和moveBy()方法。

#### 窗口大小

innerWidth、innerHeight、outerWidth、outerHeight。
resizeTo()、resizeBy()方法可以调整浏览器窗口的大小。

#### 导航和打开窗口

window.open()。

1. 弹出窗口
window.close()，仅适用于window.open()打开的窗口，对于浏览器的主窗口，如果没有得到用户允许是不能关闭它的。
新创建的window对象有一个opener属性，其中保存着打开他的原始窗口对象。

2. 安全限制（弹出窗口）
弹出窗口屏蔽程序

#### 间歇调用和超时调用：

超时调用：
setTimeout()，第一个参数可以是包含JS代码的字符串，也可以是一个函数（推荐），第二个参数是毫秒表示的时间。调用setTimeout()方法之后，会返回一个数值ID，表示超时调用，这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。
例如：

``` js
//设置超时调用
var timeoutId = setTimeout(function(){
	alert("hello world !");
}, 1000);
//把它取消
clearTimeout(timeoutId);
//执行以上代码什么都不会发生。
```

间歇调用：
setInterval()，clearInterval()使用与超时调用类似。

超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模式下指向window 对象，在严格模式下是undefined。

#### 系统对话框：

- alert()
- confirm()
- prompt()

浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。

- print()，显示打印对话框
- find()，显示查找对话框

这两个对话框都是异步显示的，能够将控制权立即交还给脚本。这两个对话框与用户通过浏览器菜单的“查找”和“打印”命令打开的对话框相同。

### location对象

location 是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document 对象的属性；换句话说，window.location 和document.location 引用的是同一个对象。location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下表列出了location 对象的所有属性（注：省略了每个属性前面的location 前缀）。

|属性名|例子|说明
|--|--|
|hash |"#contents" |返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串
|host |"www.wrox.com:80" |返回服务器名称和端口号（如果有）
|hostname |"www.wrox.com" |返回不带端口号的服务器名称
|href |"http:/www.wrox.com" |返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值
|pathname |"/WileyCDA/" |返回URL中的目录和（或）文件名
|port |"8080" |返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串
|protocol |"http:" |返回页面使用的协议。通常是http:或https:
|search |"?q=javascript" |返回URL的查询字符串。这个字符串以问号开头

**位置操作**

使用location 对象可以通过很多方式来改变浏览器的位置。首先，也是最常用的方式，就是使用assign()方法并为其传递一个URL，如下所示。

``` js
location.assign("http://www.wrox.com");
```

这样，就可以立即打开新URL 并在浏览器的历史记录中生成一条记录。如果是将location.href或window.location 设置为一个URL 值，也会以该值调用assign()方法。例如，下列两行代码与显式调用assign()方法的效果完全一样。

``` js
window.location = "http://www.wrox.com";
location.href = "http://www.wrox.com";
```

在这些改变浏览器位置的方法中，最常用的是设置location.href 属性。
另外，修改location 对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将hash、search、hostname、pathname 和port 属性设置为新值来改变URL。
``` js
//假设初始URL 为http://www.wrox.com/WileyCDA/
//将URL 修改为"http://www.wrox.com/WileyCDA/#section1"
location.hash = "#section1";
//将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"
location.search = "?q=javascript";
//将URL 修改为"http://www.yahoo.com/WileyCDA/"
location.hostname = "www.yahoo.com";
//将URL 修改为"http://www.yahoo.com/mydir/"
location.pathname = "mydir";
//将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"
location.port = 8080;
```

每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。

在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览器的历史记录中生成一条新记录。在IE 的早期版本中，hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash 的URL 时才会被更新。

当通过上述任何一种方式修改URL 之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用replace()方法。这个方法只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。

与位置有关的最后一个方法是reload()，作用是重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。
``` js
location.reload(); //重新加载（有可能从缓存中加载）
location.reload(true); //重新加载（从服务器重新加载）
```

位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。

### navigator对象

- appName，完整的浏览器名称
- userAgent，浏览器的用户代理字符串
- platform，浏览器所在的系统平台
- language，浏览器的主语言
- plugins，浏览器中安装的插件信息的数组

**1. 插件检测**

非IE：navigator.plugins
IE：ActiveXObject

plugins 集合有一个名叫refresh()的方法，用于刷新plugins 以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。

**2. 注册处理程序**

- registerContentHandler()
- registerProtocolHandler()

### screen对象

### history对象

history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。
使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。
也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做。
另外，还可以使用两个简写方法back()和forward()来代替go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。
除了上述几个方法外，history 对象还有一个length 属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于0。通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的页面。

*当页面的URL 改变时，就会生成一条历史记录。在IE8 及更高版本、Opera、Firefox、Safari 3 及更高版本以及Chrome 中，这里所说的改变包括URL 中hash 的变化（因此，设置location.hash 会在这些浏览器中生成一条新的历史记录）。*


## 第九章 客户端检测

1. 能力检测（特性检测）
2. 怪癖检测
3. 用户代理检测
用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP 请求过程中，用户代理字符串是作为响应首部发送的，而且该字符串可以通过JavaScript 的navigator.userAgent 属性访问。在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。而在客户端，用户代理检测一般被当作一种万不得已才用的做法，其优先级排在能力检测和（或）怪癖检测之后。

主流四大浏览器内核：
- Trident ：Internet Explore
- Gecko：Mozilla Firefox、Netscape
- WebKit：Safari、Chrome
- Presto：Opera

以下是完整的用户代理字符串检测脚本，包括检测呈现引擎、平台、Windows 操作系统、移动设备和游戏系统。
``` js
var client = function () {
  //呈现引擎
  var engine = {
    ie: 0,
    gecko: 0,
    webkit: 0,
    khtml: 0,
    opera: 0,
    //完整的版本号
    ver: null
  };
  //浏览器
  var browser = {
    //主要浏览器
    ie: 0,
    firefox: 0,
    safari: 0,
    konq: 0,
    opera: 0,
    chrome: 0,
    //具体的版本号
    ver: null
  };
  //平台、设备和操作系统
  var system = {
    win: false,
    mac: false,
    x11: false,
    //移动设备
    iphone: false,
    ipod: false,
    ipad: false,
    ios: false,
    android: false,
    nokiaN: false,
    winMobile: false,
    //游戏系统
    wii: false,
    ps: false
  };
  //检测呈现引擎和浏览器
  var ua = navigator.userAgent;
  if (window.opera) {
    engine.ver = browser.ver = window.opera.version();
    engine.opera = browser.opera = parseFloat(engine.ver);
  } else if (/AppleWebKit\/(\S+)/.test(ua)) {
    engine.ver = RegExp["$1"];
    engine.webkit = parseFloat(engine.ver);
    //确定是Chrome 还是Safari
    if (/Chrome\/(\S+)/.test(ua)) {
      browser.ver = RegExp["$1"];
      browser.chrome = parseFloat(browser.ver);
    } else if (/Version\/(\S+)/.test(ua)) {
      browser.ver = RegExp["$1"];
      browser.safari = parseFloat(browser.ver);
    } else {
      //近似地确定版本号
      var safariVersion = 1;
      if (engine.webkit < 100) {
        safariVersion = 1;
      } else if (engine.webkit < 312) {
        safariVersion = 1.2;
      } else if (engine.webkit < 412) {
        safariVersion = 1.3;
      } else {
        safariVersion = 2;
      }
      browser.safari = browser.ver = safariVersion;
    }
  } else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) {
    engine.ver = browser.ver = RegExp["$1"];
    engine.khtml = browser.konq = parseFloat(engine.ver);
  } else if (/rv:([^\)]+)\) Gecko\/\d{8}/.test(ua)) {
    engine.ver = RegExp["$1"];
    engine.gecko = parseFloat(engine.ver);
    //确定是不是Firefox
    if (/Firefox\/(\S+)/.test(ua)) {
      browser.ver = RegExp["$1"];
      browser.firefox = parseFloat(browser.ver);
    }
  } else if (/MSIE ([^;]+)/.test(ua)) {
    engine.ver = browser.ver = RegExp["$1"];
    engine.ie = browser.ie = parseFloat(engine.ver);
  }
  //检测浏览器
  browser.ie = engine.ie;
  browser.opera = engine.opera;
  //检测平台
  var p = navigator.platform;
  system.win = p.indexOf("Win") == 0;
  system.mac = p.indexOf("Mac") == 0;
  system.x11 = (p == "X11") || (p.indexOf("Linux") == 0);
  //检测Windows 操作系统
  if (system.win) {
    if (/Win(?:dows )?([^do]{2})\s?(\d+\.\d+)?/.test(ua)) {
      if (RegExp["$1"] == "NT") {
        switch (RegExp["$2"]) {
          case "5.0":
            system.win = "2000";
            break;
          case "5.1":
            system.win = "XP";
            break;
          case "6.0":
            system.win = "Vista";
            break;
          case "6.1":
            system.win = "7";
            break;
          default:
            system.win = "NT";
            break;
        }
      } else if (RegExp["$1"] == "9x") {
        system.win = "ME";
      } else {
        system.win = RegExp["$1"];
      }
    }
  }
  //移动设备
  system.iphone = ua.indexOf("iPhone") > -1;
  system.ipod = ua.indexOf("iPod") > -1;
  system.ipad = ua.indexOf("iPad") > -1;
  system.nokiaN = ua.indexOf("NokiaN") > -1;
  //windows mobile
  if (system.win == "CE") {
    system.winMobile = system.win;
  } else if (system.win == "Ph") {
    if (/Windows Phone OS (\d+.\d+)/.test(ua)) {
      ;
      system.win = "Phone";
      system.winMobile = parseFloat(RegExp["$1"]);
    }
  }
  //检测iOS 版本
  if (system.mac && ua.indexOf("Mobile") > -1) {
    if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)) {
      system.ios = parseFloat(RegExp.$1.replace("_", "."));
    } else {
      system.ios = 2; //不能真正检测出来，所以只能猜测
    }
  }
  //检测Android 版本
  if (/Android (\d+\.\d+)/.test(ua)) {
    system.android = parseFloat(RegExp.$1);
  }
  //游戏系统
  system.wii = ua.indexOf("Wii") > -1;
  system.ps = /playstation/i.test(ua);
  //返回这些对象
  return {
    engine: engine,
    browser: browser,
    system: system
  };
}();
```


## 第十章 DOM

DOM（文档对向模型）是针对HTML和XML文档的一个API。
DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。
1998 年10 月DOM１级规范成为W3C 的推荐标准，为基本的文档结构及查询提供了接口。

*注意，IE 中的所有DOM 对象都是以COM 对象的形式实现的。这意味着IE 中的DOM 对象与原生JavaScript 对象的行为或活动特点并不一致。本章将较多地谈及这些差异。*

### 节点层次

DOM 可以将任何HTML 或XML 文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。
以下面的HTML 为例：

``` xml
<html>
  <head>
    <title>Sample Page</title>
  </head>
  <body>
    <p>Hello World!</p>
  </body>
</html>
```

文档节点（document）是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<html>元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在HTML 页面中，文档元素始终都是<html>元素。在XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。

每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12 种节点类型，这些类型都继承自一个基类型。

#### Node类型

DOM1 级定义了一个Node 接口，该接口将由DOM 中的所有节点类型实现。这个Node 接口在JavaScript 中是作为Node 类型实现的；除了IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自Node 类型，因此所有节点类型都共享着相同的基本属性和方法。

**1. nodeType属性**

每个节点都有一个nodeType属性，用于表明节点的类型。节点类型由在Node类型中定义的下列12个常量属性来表示：
1. Node.ELEMENT_NODE=1
2. Node.ATTRIBUTE_NODE=2
3. Node.TEXT_NODE=3
4. Node.CDATA_SECTION_NODE=4
5. Node.ENTITY_REFERENCE_NODE=5
6. Node.ENTITY_NODE=6
7. Node.PROCESSING_INSTRUCTION_NODE=7
8. Node.COMMENT_NODE=8
9. Node.DOCUMENT_NODE=9
10. Node.DOCUMENT_TYPE_NODE=10
11. Node.DOCUMENT_FRAGMENT_NODE=11
12. Node.NOTATION_NODE=12

**2. nodeName和nodeValue属性**

要了解节点的具体信息，可以使用nodeName 和nodeValue 这两个属性。这两个属性的值完全取决于节点的类型。
对于元素节点，nodeName中保存的始终都是元素的标签名，而nodeValue的值始终为null。

**3. 节点关系**

- childNodes（childNode[0]或者childNodes.item(0)访问）
- parentNode
- previousSibling
- nextSibling
- firstChild （=childNodes[0]）
- lastChild （=childNodes[length-1]）
文档中所有的节点之间都存在这样或那样的关系。节点间的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。在HTML 中，可以将<body>元素看成是<html>元素的子元素；相应地，也就可以将<html>元素看成是<body>元素的父元素。而<head>元素，则可以看成是<body>元素的同胞元素，因为它们都是同一个父元素<html>的直接子元素。
每个节点都有一个childNodes 属性，其中保存着一个NodeList 对象。NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来访问NodeList 的值，而且这个对象也有length 属性，但它并不是Array 的实例。NodeList 对象的独特之处在于，它实际上是基于DOM 结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList 对象中。我们常说，NodeList 是有生命、有呼吸的对象，而不是在我们第一次访问它们的某个瞬间拍摄下来的一张快照。

每个节点都有一个parentNode 属性，该属性指向文档树中的父节点。包含在childNodes 列表中的所有节点都具有相同的父节点，因此它们的parentNode 属性都指向同一个节点。此外，包含在childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的previousSibling和nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的previousSibling 属性值为null，而列表中最后一个节点的nextSibling 属性的值同样也为null

hasChildNodes()方法在节点包含一个或多个子节点的情况下返回true。
所有节点都有的一个属性是ownerDocument，该属性指向表示整个文档的文档节点。

*虽然所有节点类型都继承自Node，但并不是每种节点都有子节点。*


**4. 操作节点**

- appendChild()
因为关系指针都是只读的，所以DOM 提供了一些操作节点的方法。其中，最常用的方法是appendChild()，用于向childNodes 列表的末尾添加一个节点。添加节点后，childNodes 的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，appendChild()返回新增的节点。
如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。即使可以将DOM树看成是由一系列指针连接起来的，但任何DOM节点也不能同时出现在文档中的多个位置上。因此，如果在调用appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点，

- insertBefore()
如果需要把节点放在childNodes 列表中某个特定的位置上，而不是放在末尾，那么可以使用insertBefore()方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），同时被方法返回。如果参照节点是null，则insertBefore()与appendChild()执行相同的操作。
在使用replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。

- replaceChild()
replaceChild()方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。

- removeChild()
如果只想移除而非替换节点，可以使用removeChild()方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值。
与使用replaceChild()方法一样，通过removeChild()移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。

*前面介绍的四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点（使用parentNode 属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。*

**5. 其他方法**

所有类型的节点都有的两个方法：

- cloneNode()
cloneNode()方法用于创建节点副本，传入参数true表示执行深度复制（复制节点及整个子节点树），false执行浅复制（只复制节点本身）。
*cloneNode()方法不会复制添加到DOM 节点中的JavaScript 属性，例如事件处理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点，其他一切都不会复制。IE 在此存在一个bug，即它会复制事件处理程序，所以我们建议在复制之前最好先移除事件处理程序。*

- normalize()
这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。

#### Document类型

JavaScript 通过Document 类型表示文档。在浏览器中，document 对象是HTMLDocument（继承自Document 类型）的一个实例，表示整个HTML 页面。而且，document 对象是window 对象的一个属性，因此可以将其作为全局对象来访问。Document 节点具有下列特征：

- nodeType值为9
- nodeName值为"#document"
- nodeValue、parentNode、ownerDocument值为null
- 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。

Document 类型可以表示HTML 页面或者其他基于XML 的文档。不过，最常见的应用还是作为HTMLDocument 实例的document 对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。

**1. 文档子节点**

虽然DOM 标准规定Document 节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是documentElement属性，该属性始终指向HTML 页面中的<html>元素。另一个就是通过childNodes 列表访问文档元素，但通过documentElement 属性则能更快捷、更直接地访问该元素。

作为HTMLDocument 的实例，document 对象还有一个body 属性，直接指向<body>元素

Document 另一个可能的子节点是DocumentType。通常将<!DOCTYPE>标签看成一个与文档其他部分不同的实体，可以通过doctype 属性（在浏览器中是document.doctype）来访问它的信息。各个浏览器对document.doctype 的支持有所不同。

**2. 文档信息**

- title属性
- URL属性
- domain属性
- referrer属性

作为HTMLDocument 的一个实例，document 对象还有一些标准的Document 对象所没有的属性。这些属性提供了document 对象所表现的网页的一些信息。其中第一个属性就是title，包含着<title>元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。修改title 属性的值不会改变<title>元素。

URL 属性中包含页面完整的URL（即地址栏中显示的URL）
domain 属性中只包含页面的域名
referrer属性中则保存着链接到当前页面的那个页面的URL。在没有来源页面的情况下，referrer 属性中可能会包含空字符串。所有这些信息都存在于请求的HTTP 头部，只不过是通过这些属性让我们能够在JavaScrip 中访问它们而已。
在这3 个属性中，只有domain 是可以设置的。但由于安全方面的限制，也并非可以给domain 设置任何值。如果URL 中包含一个子域名，例如p2p.wrox.com，那么就只能将domain 设置为"wrox.com"（URL 中包含"www"，如www.wrox.com 时，也是如此）。不能将这个属性设置为URL 中不包含的域。

当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain 就非常方便了。由于跨域安全限制， 来自不同子域的页面无法通过JavaScript 通信。而通过将每个页面的document.domain 设置为相同的值，这些页面就可以互相访问对方包含的JavaScript 对象了。例如，假设有一个页面加载自www.wrox.com，其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com。由于document.domain 字符串不一样，内外两个页面之间无法相互访问对方的JavaScript 对象。但如果将这两个页面的document.domain 值都设置为"wrox.com"，它们之间就可以通信了。

浏览器对domain 属性还有一个限制，即如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）。换句话说，在将document.domain 设置为"wrox.com"之后，就不能再将其设置回"p2p.wrox.com"，否则将会导致错误，

**3. 查找元素**

1. getElementById()
2. getElementByTagName()
2. getElementByName()

第一个方法，getElementById()，接收一个参数：要取得的元素的ID。如果找到相应的元素则返回该元素，如果不存在带有相应ID 的元素，则返回null。注意，这里的ID 必须与页面中元素的id特性（attribute）严格匹配，包括大小写。
如果页面中多个元素的ID 值相同，getElementById()只返回文档中第一次出现的元素。

另一个常用于取得元素引用的方法是getElementsByTagName()。这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的NodeList。在HTML 文档中，这个方法会返回一个HTMLCollection 对象。

作为一个“动态”集合，该对象与NodeList 非常类似，可以通过下标（方括号）或item()方法取得其中值，如果包含name属性，也可以通过namedItem()方法取得。

要想取得文档中的所有元素，可以向getElementsByTagName()中传入"*"。

*对HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用item()，而对字符串索引就会调用namedItem()。*

第三个方法，也是只有HTMLDocument 类型才有的方法，是getElementsByName()。顾名思义，这个方法会返回带有给定name 特性的所有元素。最常使用getElementsByName()方法的情况是取得单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的name 特性。

与getElementsByTagName()类似，getElementsByName()方法也会返回一个HTMLCollectioin。但是，对于单选按钮来说，namedItem()方法则只会取得第一项（因为单选按钮每一项的name 特性都相同）

**4. 特殊集合**

除了属性和方法，document 对象还有一些特殊的集合。这些集合都是HTMLCollection 对象，为访问文档常用的部分提供了快捷方式，包括：

- document.anchors，包含文档中所有带name 特性的<a>元素；
- document.applets，包含文档中所有的<applet>元素，因为不再推荐使用<applet>元素，所以这个集合已经不建议使用了；
- document.forms，包含文档中所有的<form>元素，与document.getElementsByTagName("form")得到的结果相同；
- document.images，包含文档中所有的<img>元素，与document.getElementsByTagName("img")得到的结果相同；
- document.links，包含文档中所有带href 特性的<a>元素。

这个特殊集合始终都可以通过HTMLDocument 对象访问到，而且，与HTMLCollection 对象类似，集合中的项也会随着当前文档内容的更新而更新。

**5. DOM一致性检测**

document.implementation.hasFeature("XML", "1.0")，返回true或者false。

尽管使用hasFeature()确实方便，但也有缺点。因为实现者可以自行决定是否与DOM 规范的不同部分保持一致。事实上，要想让hasFearture()方法针对所有值都返回true 很容易，但返回true有时候也不意味着实现与规范一致。例如，Safari 2.x 及更早版本会在没有完全实现某些DOM 功能的情况下也返回true。为此，我们建议多数情况下，在使用DOM 的某些特殊的功能之前，最好除了检测hasFeature()之外，还同时使用能力检测。

**6. 文档写入**

- write()
- writeln()
- open()
- close()

其中，write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。write()会原样写入，而writeln()则会在字符串的末尾添加一个换行符（\n）。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容。

此外，还可以使用write()和writeln()方法动态地包含外部资源，例如JavaScript 文件等。在包含JavaScript 文件时，必须注意不能像下面的例子那样直接包含字符串"</script>"，因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行，解决办法是对改字符串进行转义，即写成"<\/script>"。

如果使用document.write()不是在页面被呈现的（加载）过程中直接向其中输出内容，而是在文档加载结束（window.onload事件）后再调用document.write()，那么输出的内容将会重写整个页面。

方法open()和close()分别用于打开和关闭网页的输出流。如果是在页面加载期间使用write()或writeln()方法，则不需要用到这两个方法。

*严格型XHTML 文档不支持文档写入。对于那些按照application/xml+xhtml内容类型提供的页面，这两个方法也同样无效。*

#### Element类型

除了Document 类型之外，Element 类型就要算是Web 编程中最常用的类型了。Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element 节点具有以下特征：

- nodeType 的值为1；
- nodeName 的值为元素的标签名；
- nodeValue 的值为null；
- parentNode 可能是Document 或Element；
- 其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection 或EntityReference。

要访问元素的标签名，可以使用nodeName 属性，也可以使用tagName 属性；这两个属性会返回相同的值（使用后者主要是为了清晰起见）。

在HTML 中，标签名始终都以全部大写表示；而在XML（有时候也包括XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在HTML 还是XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式。

**1. HTML元素**

所有HTML 元素都由HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement 类型直接继承自Element 并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。

- id，元素在文档中的唯一标识符。
- title，有关元素的附加说明信息，一般通过工具提示条显示出来。
- lang，元素内容的语言代码，很少使用。
- dir，语言的方向，值为"ltr"（left-to-right，从左至右）或"rtl"（right-to-left，从右至左），也很少使用。
- className，与元素的class 特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为class 是ECMAScript 的保留字。

**2. 取得特性**

- getAttribute()

注意，传递给getAttribute()的特性名与实际的特性名相同。因此要想得到class 特性值，应该传入"class"而不是"className"，后者只有在通过对象属性访问特性时才用。如果给定名称的特性不存在，getAttribute()返回null。

通过getAttribute()方法也可以取得自定义特性（即标准HTML 语言中没有的特性）的值，不过，特性的名称是不区分大小写的，即"ID"和"id"代表的都是同一个特性。另外也要注意，根据HTML5 规范，自定义特性应该加上data-前缀以便验证。

任何元素的所有特性，也都可以通过DOM 元素本身的属性来访问。当然，HTMLElement 也会有5个属性与相应的特性一一对应。不过，只有公认的（非自定义的）特性才会以属性的形式添加到DOM对象中。

有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同。第一类特性就是style，用于通过CSS 为元素指定样式。在通过getAttribute()访问时，返回的style 特性值中包含的是CSS 文本，而通过属性来访问它则会返回一个对象。由于style 属性是用于以编程方式访问元素样式的，因此并没有直接映射到style 特性。

第二类与众不同的特性是onclick 这样的事件处理程序。当在元素上使用时，onclick 特性中包含的是JavaScript 代码，如果通过getAttribute()访问，则会返回相应代码的字符串。而在访问onclick 属性时，则会返回一个JavaScript 函数（如果未在元素中指定相应特性，则返回null）。这是因为onclick 及其他事件处理程序属性本身就应该被赋予函数值。

由于存在这些差别，在通过JavaScript 以编程方式操作DOM 时，开发人员经常不使用getAttribute()，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用getAttribute()方法。

**3. 设置特性**

- setAttribute()

这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()则创建该属性并设置相应的值。

通过setAttribute()方法既可以操作HTML 特性也可以操作自定义特性。通过这个方法设置的特性名会被统一转换为小写形式，即"ID"最终会变成"id"。

- removeAttribute()

这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性。
这个方法并不常用，但在序列化DOM 元素时，可以通过它来确切地指定要包含哪些特性。

**4. attributes属性**

**5. 创建元素**

createElement()方法创建新元素，IE中可以直接传入标签来创建。

**6. 元素子节点**

### Text类型

文本节点由Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML 字符，但不能包含HTML 代码。Text 节点具有以下特征：

- nodeType 的值为3；
- nodeName 的值为"#text"；
- nodeValue 的值为节点所包含的文本；
- parentNode 是一个Element；
- 不支持（没有）子节点。

可以通过nodeValue 属性或data 属性访问Text 节点中包含的文本，这两个属性中包含的值相同。对nodeValue 的修改也会通过data 反映出来，反之亦然。使用下列方法可以操作节点中的文本：

- appendData(text)：将text 添加到节点的末尾。
- deleteData(offset, count)：从offset 指定的位置开始删除count 个字符。
- insertData(offset, text)：在offset 指定的位置插入text。
- replaceData(offset, count, text)：用text 替换从offset 指定的位置开始到offset+count 为止处的文本。
- splitText(offset)：从offset 指定的位置将当前文本节点分成两个文本节点。
- substringData(offset, count)：提取从offset 指定的位置开始到offset+count 为止处的字符串。

除了这些方法之外，文本节点还有一个length 属性，保存着节点中字符的数目。而且，nodeValue.length 和data.length 中也保存着同样的值。在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。

**1. 创建文本节点**

createTextNode()。

**2. 规范化文本节点**

normalize()方法，在包含两个或多个文本节点的父元素上调用normalize方法时，则会将所有文本节点合并成一个节点。

**3. 分隔文本节点**

Text 类型提供了一个作用与normalize()相反的方法：splitText()。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割nodeValue 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的。parentNode 相同。

#### Comment类型

注释在DOM中是通过Comment 类型来表示的。Comment 节点具有下列特征：

- nodeType 的值为8；
- nodeName 的值为"#comment"；
- nodeValue 的值是注释的内容；
- parentNode 可能是Document 或Element；
- 不支持（没有）子节点。

Comment 类型与Text 类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。与Text 类型相似，也可以通过nodeValue 或data 属性来取得注释的内容。
注释节点可以通过其父节点来访问，

createComment()方法创建注释节点，浏览器不会识别位于< html>标签外的注释。

#### CDATASection类型

CDATASection 类型只针对基于XML 的文档，表示的是CDATA 区域。与Comment 类似，CDATASection 类型继承自Text 类型，因此拥有除splitText()之外的所有字符串操作方法。
CDATASection 节点具有下列特征：

- nodeType 的值为4；
- nodeName 的值为"#cdata-section"；
- nodeValue 的值是CDATA 区域中的内容；
- parentNode 可能是Document 或Element；
- 不支持（没有）子节点。

CDATA 区域只会出现在XML 文档中，因此多数浏览器都会把CDATA 区域错误地解析为Comment或Element。

#### DocumentType类型

不常用，仅Firefox，Safari，Opera支持，浏览器会把DocumentType对象保存在document.doctype中，包括三个属性：name，entities，notations。

#### DocumentFragment类型

在所有节点类型中，只有DocumentFragment 在文档中没有对应的标记。DOM 规定文档片段（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。
DocumentFragment 节点具有下列特征：

- nodeType 的值为11；
- nodeName 的值为"#document-fragment"；
- nodeValue 的值为null；
- parentNode 的值为null；
- 子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection 或EntityReference。

虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。要创建文档片段，可以使用document.createDocumentFragment()方法。


#### Attr类型

元素的特性在DOM 中以Attr 类型来表示。在所有浏览器中（包括IE8），都可以访问Attr 类型的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes 属性中的节点。特性节点具有下列特征：

- nodeType 的值为2；
- nodeName 的值是特性的名称；
- nodeValue 的值是特性的值；
- parentNode 的值为null；
- 在HTML 中不支持（没有）子节点；
- 在XML 中子节点可以是Text 或EntityReference。
- 尽管它们也是节点，但特性却不被认为是DOM 文档树的一部分。开发人员最常使用的是getAttribute()、setAttribute()和remveAttribute()方法，很少直接引用特性节点。

Attr 对象有3 个属性：name、value 和specified。其中，name 是特性名称（与nodeName 的值相同），value 是特性的值（与nodeValue 的值相同），而specified 是一个布尔值，用以区别特性是在代码中指定的，还是默认的。

使用document.createAttribute()并传入特性的名称可以创建新的特性节点。例如，要为元素添加align 特性，可以使用下列代码：

``` js
var attr = document.createAttribute("align");
attr.value = "left";
element.setAttributeNode(attr);
alert(element.attributes["align"].value); //"left"
alert(element.getAttributeNode("align").value); //"left"
alert(element.getAttribute("align")); //"left"
```

这个例子创建了一个新的特性节点。由于在调用createAttribute()时已经为name 属性赋了值，所以后面就不必给它赋值了。之后，又把value 属性的值设置为"left"。为了将新创建的特性添加到元素中，必须使用元素的setAttributeNode()方法。添加特性之后，可以通过下列任何方式访问该特性：attributes 属性、getAttributeNode()方法以及getAttribute()方法。其中，attributes和getAttributeNode()都会返回对应特性的Attr 节点，而getAttribute()则只返回特性的值。

### DOM操作技术

#### 1. 动态脚本

使用<script>元素可以向页面中插入JavaScript 代码，一种方式是通过其src 特性包含外部文件，另一种方式就是用这个元素本身来包含代码。而这一节要讨论的动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改DOM 动态添加的脚本。跟操作HTML 元素一样，创建动态脚本也有两种方式：插入外部文件和直接插入JavaScript 代码。

动态加载的外部JavaScript 文件能够立即运行，比如下面的<script>元素：

``` xml
<script type="text/javascript" src="client.js"></script>
```

``` js
function loadScript(url){
  var script = document.createElement("script");
  script.type = "text/javascript";
  script.src = url;
  document.body.appendChild(script);
}
loadScript("client.js");
```

``` js
function loadScriptString(code){
	var script = document.createElement("script");
	script.type = "text/javascript";
	try {
	  script.appendChild(document.createTextNode(code));
	} catch (ex){
	  script.text = code; // 兼容IE
	}
	document.body.appendChild(script);
}
loadScriptString("function sayHi(){alert('hi');}");
```
*以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给eval()是一样的。*

### 2. 动态样式

能够把CSS 样式包含到HTML 页面中的元素有两个。其中，<link>元素用于包含来自外部的文件，而<style>元素用于指定嵌入的样式。与动态脚本类似，所谓动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。

``` js
function loadStyles(url){
  var link = document.createElement("link");
  link.rel = "stylesheet";
	link.type = "text/css";
	link.href = url;
	var head = document.getElementsByTagName("head")[0];
	head.appendChild(link);
}
loadStyles("styles.css");
```

需要注意的是，必须将<link>元素添加到<head>而不是<body>元素，才能保证在所有浏览器中的行为一致。

加载外部样式文件的过程是异步的，也就是加载样式与执行JavaScript 代码的过程没有固定的次序。

``` js
function loadStyleString(css){
	var style = document.createElement("style");
	style.type = "text/css";
	try{
	  style.appendChild(document.createTextNode(css));
	} catch (ex){
	  style.styleSheet.cssText = css; // 兼容IE
	}
	var head = document.getElementsByTagName("head")[0];
	head.appendChild(style);
}
loadStyleString("body{background-color:red}");
```

#### 3. 操作表格

为了方便构建表格，HTML DOM 还为<table>、<tbody>和<tr>元素添加了一些属性和方法。

为<table>元素添加的属性和方法如下：

- caption：保存着对<caption>元素（如果有）的指针。
- tBodies：是一个<tbody>元素的HTMLCollection。
- tFoot：保存着对<tfoot>元素（如果有）的指针。
- tHead：保存着对<thead>元素（如果有）的指针。
- rows：是一个表格中所有行的HTMLCollection。
- createTHead()：创建<thead>元素，将其放到表格中，返回引用。
- createTFoot()：创建<tfoot>元素，将其放到表格中，返回引用。
- createCaption()：创建<caption>元素，将其放到表格中，返回引用。
- deleteTHead()：删除<thead>元素。
- deleteTFoot()：删除<tfoot>元素。
- deleteCaption()：删除<caption>元素。
- deleteRow(pos)：删除指定位置的行。
- insertRow(pos)：向rows 集合中的指定位置插入一行。

为<tbody>元素添加的属性和方法如下：

- rows：保存着<tbody>元素中行的HTMLCollection。
- deleteRow(pos)：删除指定位置的行。
- insertRow(pos)：向rows 集合中的指定位置插入一行，返回对新插入行的引用。

为<tr>元素添加的属性和方法如下：

- cells：保存着<tr>元素中单元格的HTMLCollection。
- deleteCell(pos)：删除指定位置的单元格。
- insertCell(pos)：向cells 集合中的指定位置插入一个单元格，返回对新插入单元格的引用。

使用这些属性和方法，可以极大地减少创建表格所需的代码数量

#### 4. 使用NodeList

理解NodeList 及其“近亲”NamedNodeMap 和HTMLCollection，是从整体上透彻理解DOM的关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息。从本质上说，所有NodeList 对象都是在访问DOM文档时实时运行的查询。
例如，下列代码会导致无限循环：

``` js
var divs = document.getElementsByTagName("div"), i, div;
for(i=0len=divs.length; i < len; i++){
  div = document.createElement("div");
  document.body.appendChild(div);
}
// >
```

第一行代码会取得文档中所有<div>元素的HTMLCollection。由于这个集合是“动态的”，因此只要有新<div>元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将创建的所有集合都保存在一个列表中，而是在下一次访问集合时再更新集合。结果，在遇到上例中所示的循环代码时，就会导致一个有趣的问题。每次循环都要对条件i < divs.length 求值，意味着会运行取得所有<div>元素的查询。考虑到循环体每次都会创建一个新<div>元素并将其添加到文档中，因此divs.length 的值在每次循环后都会递增。既然i 和divs.length 每次都会同时递增，结果它们的值永远也不会相等。

如果想要迭代一个NodeList，最好是使用length 属性初始化第二个变量，然后将迭代器与该变量进行比较，如下面的例子所示：

``` js
var divs = document.getElementsByTagName("div"), i, len, div;
for (i=0, len=divs.length; i < len; i++){
  div = document.createElement("div");
  document.body.appendChild(div);
}
// >
```

这个例子中初始化了第二个变量len。由于len 中保存着对divs.length 在循环开始时的一个快照，因此就会避免上一个例子中出现的无限循环问题。

一般来说，应该尽量减少访问NodeList 的次数。因为每次访问NodeList，都会运行一次基于文档的查询。所以，可以考虑将从NodeList 中取得的值缓存起来。

## 第十一章 DOM 扩展

尽管DOM 作为API 已经非常完善了，但为了实现更多的功能，仍然会有一些标准或专有的扩
展。2008 年之前，浏览器中几乎所有的DOM扩展都是专有的。此后，W3C 着手将一些已经
成为事实标准的专有扩展标准化并写入规范当中。

对DOM 的两个主要的扩展是Selectors API（选择符API）和HTML5。这两个扩展都源自开发社区，而将某些常见做法及API 标准化一直是众望所归。此外，还有一个不那么引人瞩目的Element Traversal（元素遍历）规范，为DOM添加了一些属性。虽然前述两个主要规范（特别是HTML5）已经涵盖了大量的DOM 扩展，但专有扩展依然存在。

### 1. 选择符API

众多JavaScript 库中最常用的一项功能，就是根据CSS 选择符选择与某个模式匹配的DOM 元素。实际上，jQuery（www.jquery.com）的核心就是通过CSS 选择符查询DOM文档取得元素的引用，从而抛开了getElementById()和getElementsByTagName()。

Selectors API（www.w3.org/TR/selectors-api/）是由W3C 发起制定的一个标准，致力于让浏览器原生支持CSS 查询。所有实现这一功能的JavaScript 库都会写一个基础的CSS 解析器，然后再使用已有的DOM 方法查询文档并找到匹配的节点。尽管库开发人员在不知疲倦地改进这一过程的性能，但到头来都只能通过运行JavaScript 代码来完成查询操作。而把这个功能变成原生API 之后，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。

Selectors API Level 1 的核心是两个方法：querySelector()和querySelectorAll()。在兼容的浏览器中，可以通过Document 及Element 类型的实例调用它们。目前已完全支持Selectors API Level 1的浏览器有IE 8+、Firefox 3.5+、Safari 3.1+、Chrome 和Opera 10+。

#### querySelector()方法

querySelector()方法接收一个CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。

通过Document 类型调用querySelector()方法时，会在文档元素的范围内查找匹配的元素。而通过Element 类型调用querySelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。CSS 选择符可以简单也可以复杂，视情况而定。如果传入了不被支持的选择符，querySelector()会抛出错误。

#### querySelectorAll()方法

querySelectorAll()方法接收的参数与querySelector()方法一样，都是一个CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个NodeList 的实例。

具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用NodeList 对象通常会引起的大多数性能问题。

只要传给querySelectorAll()方法的CSS 选择符有效，该方法都会返回一个NodeList 对象，而不管找到多少匹配的元素。如果没有找到匹配的元素，NodeList 就是空的。

与querySelector()类似，能够调用querySelectorAll()方法的类型包括Document、
DocumentFragment 和Element。

要取得返回的NodeList 中的每一个元素，可以使用item()方法，也可以使用方括号语法。

同样与querySelector()类似，如果传入了浏览器不支持的选择符或者选择符中有语法错误，querySelectorAll()会抛出错误。

#### matchesSelector()方法

Selectors API Level 2 规范为Element 类型新增了一个方法matchesSelector()。这个方法接收一个参数，即CSS 选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。

*目前已不支持*

### 元素遍历

对于元素间的空格，IE9 及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用childNodes 和firstChild 等属性时的行为不一致。为了弥补这一差异，而同时又保持DOM规范不变，Element Traversal 规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。

Element Traversal API 为DOM元素添加了以下5 个属性。

- childElementCount：返回子元素（不包括文本节点和注释）的个数。
- firstElementChild：指向第一个子元素；firstChild 的元素版。
- lastElementChild：指向最后一个子元素；lastChild 的元素版。
- previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。
- nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。

















## 第二十章 JSON

1、语法
JSON语法可以表示以下三种类型的值：
      ○ 简单值：可以在JSON中表示字符串（双引号）、数值、布尔值和null，不支持JS中的undefined
      ○ 对象：一组无序的键值对（对象属性名要加双引号）
      ○ 数组：一组有序的值列表（用中括号表示，不要末尾分号，与JS数组字面量表示类似）
2、解析与序列化
早期使用JS的eval()函数。
JSON对象有两个方法：
JSON.stringify();
JSON.parse();

## 第二十一章 Ajax与Comet

1、XMLHttpRequest对象
var xhr=createXHR(); //创建
xhr.open("get", "example.php", true); //准备发送
xhr.send(null); //发送
xhr.abort(); //取消发送
xhr对象具有readyState属性，取值如下：
- 0：未初始化。尚未调用open方法。
- 1：启动。已调用open，未调用send方法。
- 2：发送。已调用send方法，未接收到响应。
- 3：接收。已接收到部分数据。
- 4：完成。已接收到全部数据，而且已经可以在客户端使用了。

HTTP头部信息
setRequestHeader()方法设置自定义请求头部信息，接收两个参数，头部字段的名称和值，需在open之后，send之前调用该方法。
getResponseHeader()方法并传入头部字段名称可取得相应头部信息。
getAllResponseHeader()方法获取一个包含头部信息的长字符串。
GET请求
xhr.open("get", "example.php?name1=value1&name2=value2", true);
POST请求
xhr.open("get", "example.php", true);
send(data);
XMLHttpRequest 2级
- FormData类型
- 超时设定：timeout属性，ontimeout事件。
- overrideMimeType()方法

进度事件
- loadstart事件
- progress事件
- error事件
- abort事件
- load事件
- loadend事件

跨域资源共享
CORS（跨源资源共享）
- 设置请求头Origin
- 使用绝对地址
- 其他跨域技术：
  - 图像Ping（只能发送GET请求，无法访问服务器的响应文本）
  - JSONP（JSON with padding）（从其他域中加载代码执行，不安全，请求失败验证不容易）
  - Comet（长轮询，短轮询，定时发送数据；HTTP流，一次请求，定时发送）

服务器发送事件
- SSE（Server Send Events，服务器发送事件） API
- 事件流

Web Sockets
全双工、双向通信
建立连接取得响应后升级为Web Socket协议，URL的模式也不同，未加密http://变为
ws://，加密https://变为ws://。



